---
chapter_number: 9
title: پیچیدگی
---

هنگامی که شما به عنوان یک برنامه نویس حرفه ای کار می کنید، این احتمال وجود دارد که کسی را بشناسید (یا کسی هستید!) که این داستان ترسناک مشترک را پشت سر میگذارد : &quot;ما پنج سال پیش کار بر روی این پروژه را شروع کردیم ، و فناوری که ما از آن استفاده می کردیم / می ساختیم آن زمان مدرن بود، اما اکنون منسوخ شده است. کارها با این فناوری منسوخ پیچیده تر و پیچیده تر می شوند، بنابراین احتمال اینکه من پروژه را تمام کنم کمتر و کمتر می شود.
 اما اگر بازنویسی کنیم، می توانیم پنج سال دیگر اینجا باشیم! &quot;

یکی دیگر از داستان های معروف این است: &quot;ما نمی توانیم به اندازه کافی سریع پیشرفت کنیم تا بتوانیم مطابق با نیازهای مدرن کاربر باشیم.&quot; یا &quot;در حالی که ما در حال توسعه بودیم، شرکت X سریعتر از ما, محصولی بهتر از محصول ما نوشت.&quot; اکنون می دانیم که منشأ این مشکلات _پیچیدگی_ است. شما با یک پروژه ساده شروع می کنید که می تواند در یک ماه به پایان برسد. سپس پیچیدگی اضافه می کنید و کار سه ماه طول می کشد. سپس هر قطعه از آن را می گیرید و پیچیده تر می کنید، و کار نه ماه طول می کشد

پیچیدگی بر پیچیدگی می‌افزاید - این فقط یک امر خطی نیست. یعنی، شما نمی‌توانید فرضیاتی مانند این داشته باشید: &quot;ما 10 ویژگی داریم، بنابراین با افزودن 1 ویژگی دیگر فقط 10 درصد زمان بیشتر اضافه می شود.&quot; در واقع، این یک ویژگی جدید باید با تمام 10 ویژگی موجود شما هماهنگ شود. بنابراین، اگر ۱۰ ساعت زمان کد نویسی برای پیاده‌سازی این ویژگی طول بکشد، ممکن است ۱۰ ساعت دیگر طول بکشد تا ۱۰ ویژگی موجود به درستی با ویژگی جدید تعامل داشته باشند. هرچه ویژگی ها بیشتر باشد، هزینه افزودن یک ویژگی بالاتر می رود. با داشتن یک طرح نرم‌افزاری عالی می‌توانید این مشکل را به حداقل برسانید، اما با این وجود همیشه هزینه های اضافی جزئی برای هر ویژگی جدید وجود دارد.

برخی از پروژه ها با چنان مجموعه پیچیده ای از الزامات شروع می شوند که هرگز نسخه اول را منتشر نمیکنند. اگر در این وضعیت هستید، باید فقط ویژگی‌ها را اصلاح کنید. در اولین انتشار به خود سخت نگیرید— چیزی را منتشر کنید که کار بکند و با گذشت زمان بر کارایی آن بیافزایید.

راه‌های دیگری به غیر از افزودن ویژگی‌ها برای اضافه کردن پیچیدگی وجود دارد. معمول‌ترین روش‌ها عبارتند از:

**_گسترش هدف نرم افزار_**

به طور کلی، فقط هرگز این کار را نکنید. بخش بازاریابی شما ممکن است از فکر ساخت یک نرم افزار واحد که مالیات چندین نیاز را همزمان برطرف میکند، بسیار خوشحال باشد، اما هر زمان که پیشنهادی از این دست به میز کار شما می آید، باید تا جایی که می توانید بلند فریاد بزنید. به هدف موجود نرم افزار خود پایبند باشید. فقط باید کاری را انجام دهد که میتواند به خوبی انجام دهد، و شما موفق خواهید شد. (به شرطی که نرم افزار شما به افراد در مورد چیزی که واقعاً به آن نیاز دارند کمک کند)

**_افزودن برنامه نویسان_**

بله، درست است - افزودن افراد بیشتر به تیم ، کارها را ساده تر نمی کند. در عوض ، این پیچیدگی را اضافه می کند. یک کتاب معروف به نام &quot;The Mythical ManMonth&quot; توسط فرد بروکس نوشته شده است که این موضوع را مشخص می‌کند. اگر 10 برنامه نویس دارید، افزودن یازدهمین برنامه نویس به معنای صرف وقت برای ایجاد شیار بین برنامه نویس جدید و برنامه نویسان دیگر است ، به علاوه زمان صرف شده توسط شخص جدید در تعامل با 10 برنامه نویس موجود ، و غیره. احتمال موفقیت شما در گروه کوچکی از برنامه نویسان خبره بیشتر از گروه بزرگی از برنامه نویسان غیر متخصص است.

**_تغییر چیزهایی که لازم نیست تغییر کنند_**

هر زمان چیزی را تغییر دهید، پیچیدگی اضافه می کنید. چه این مورد نیاز باشد، طراحی، یا فقط یک قطعه کد، شما امکان ایجاد تغییر را، زمان مورد نیاز برای اجرای تغییر، زمان مورد نیاز برای ارزیابی تغییر، زمان مورد نیاز برای پی‌گیری تغییر، و زمان مورد نیاز برای آزمودن تغییر، را در نظر بگیرید. هر تغییر براساس تمام این پیچیدگی ساخته می‌شود، بنابراین هر چه بیشتر تغییر کنید، زمان بیشتری برای هر تغییر جدید ایجاد می‌شود. هنوز هم مهم است که تغییرات خاصی ایجاد کنید، اما باید تصمیمات آگاهانه در مورد آن‌ها اتخاذ کنید، نه فقط تغییر برای هوس.

**_محبوس بودن در تکنولوژی‌های بد_**

اساسا، این جایی است که شما تصمیم می‌گیرید از برخی از فن‌آوری ها استفاده کنید، و سپس برای مدتی طولانی با آن درگیر می‌شوید چون شما به آن وابسته هستید. یک فناوری به این معنا اگر شما را محصور کند &quot;بد&quot; است (به شما اجازه نمی دهد در آینده به راحتی به فناوری دیگری بروید) ، به اندازه کافی برای نیازهای آینده انعطاف پذیر نخواهد بود یا فقط از سطح کیفی که برای طراحی نرم افزار ساده با آن نیاز دارید را داشته باشید.

**_سوء تفاهم_**

برنامه نویسان که کاملاً کار خود را درک نمی کنند ، تمایل به توسعه سیستم های پیچیده دارند. این می‌تواند یک چرخه معیوب باشد: سو تفاهم منجر به پیچیدگی می‌شود که منجر به سو تفاهم بیشتر و غیره می‌شود. یکی از بهترین روش‌ها برای بهبود مهارت‌های طراحی شما این است که مطمئن شوید که سیستم و ابزارهایی که با آن‌ها کار می‌کنید را به طور کامل درک می‌کنید. هرچه بیشتر این موارد را درک کنید، و هر چه بیشتر در مورد نرم‌افزار بدانید، طرح‌های شما ساده‌ تر خواهند بود.

**_طراحی ضعیف یا بدون طراحی_**

اساساً، این فقط به معنای &quot;عدم برنامه ریزی برای تغییر&quot; است. اوضاع در حال تغییر است و برای حفظ سادگی در حین رشد پروژه کار طراحی لازم است. شما باید در ابتدا خوب طراحی کنید و همچنین با گسترش سیستم به طراحی خود ادامه دهید - در غیر این صورت ، می توانید پیچیدگی عظیم را خیلی سریع بوجود بیاورید، زیرا با یک طراحی ضعیف، هر ویژگی جدید پیچیدگی کد را چند برابر می کند به جای اینکه فقط کمی پیچیدگی اضافه کنید.

**_اختراع دوباره چرخ_**

اگر به عنوان مثال، پروتکل خود را در صورت وجود پروتکل کاملاً خوب دیگر دوباره اختراع کنید، وقت زیادی را صرف کار روی پروتکل خواهید کرد ، زمانی که می توانید روی نرم افزار خود کار کنید. شما تقریبا هرگز نباید وابستگی زیادی اختراع دوباره چیزی داشته باشید، مانند یک سرور وب، یک پروتکل یا یک کتابخانه بزرگ، مگر این که محصول شما باشد. تنها زمان‌هایی که برای دوباره اختراع چرخ مناسب است، زمانی است که هر یک از موارد زیر درست هستند:

- شما به چیزی احتیاج دارید که هنوز وجود ندارد.
- تمام &quot;چرخ&quot; های موجود فناوری های بدی هستند که شما را قفل می کنند.
- &quot;چرخ&quot; های موجود اساساً قادر به تأمین نیازهای شما نیستند.
- &quot;چرخ&quot; های موجود به درستی نگهداری نمی شوند و شما نمی توانید تعمیر و نگهداری آنها را به عهده بگیرید (به عنوان مثال ، کد منبع ندارید).

همه این عوامل به آرامی و به تدریج برای پروژه شما مضر هستند، بلافاصله مخرب نیستند. بیشتر آنها فقط آسیب های طولانی مدت میزنند - چیزی که یک سال یا بیشتر نمی بینید - بنابراین وقتی کسی آنها را پیشنهاد می کند، اغلب بی خطر به نظر می رسند. و حتی وقتی که شروع به اجرای آن‌ها می‌کنید، ممکن است خوب به نظر برسند. اما با گذشت زمان - و به خصوص بیشتر و بیشتر این انباشت - پیچیدگی آشکارتر می‌شود و رشد می‌کند و رشد می‌کند، تا زمانی که شما یک قربانی دیگر از آن داستان وحشتناک میشوید.

**پیچیدگی و هدف**

هدف اصلی هر سیستم معینی که شما روی آن کار می کنید باید کاملاً ساده باشد. این امر کمک می کند تا سیستم در کل تا جایی که میتواند واقع بینانه ای ساده باشد. اما اگر شروع به اضافه کردن ویژگی هایی کنید که هدف دیگری را برآورده میکنند، همه چیز خیلی زود پیچیده می شوند. برای مثال، هدف اولیه یک پردازشگر کلمه، کمک به شما برای نوشتن چیزی است. اگر ما به طور ناگهانی آن را قادر به خواندن ایمیل شما کنیم، به طرز مضحکی پیچیده می‌شد. می‌توانید تصور کنید که رابط کاربر چه شکلی خواهد بود؟ همه دکمه ها را کجا قرار می دهید؟ ما می‌گوییم که این هدف پردازشگر کلمه شما نقض میکند. شما حتی هدف آن را گسترش ندادید. شما فقط ویژگی هایی را اضافه کردید که هیچ ارتباطی با آن ندارند.

همچنین مهم است که به هدف کاربر فکر کنید. کاربر شما در تلاش است کاری انجام دهد. در حالت ایده آل ، هدف یک برنامه باید بسیار نزدیک به هدف کاربر باشد. برای مثال ، بگذارید بگوییم هدف کاربر انجام مالیات خود است. او نرم افزاری می خواهد که هدف آن کمک به مردم در پرداخت مالیات خود باشد.

اگر هدف شما و کاربر با هم مطابقت نداشته باشد، احتمالاً زندگی او را دشوار می کنید.  به عنوان مثال، اگر او می خواهد ایمیل خود را بخواند، اما هدف اصلی برنامه ای که استفاده می کند نمایش تبلیغات به کاربران است، این اهداف مطابقت ندارند.

آیا می خواهید کاربر شما خیلی سریع عصبانی شود؟ تحقق هدفش را برای او دشوار کنید. هنگام تلاش برای انجام کاری، پنجره های نامربوط را باز کنید. آنقدر ویژگی به برنامه خود اضافه کنید که او نتواند ویژگی مناسب را پیدا کند. از نمادهای عجیب و غریب زیادی استفاده کنید که او نمی فهمد. روش های زیادی برای انجام این کار وجود دارد ، اما همه آنها منجر به تداخل در هدف کاربر یا نقض هدف اصلی خود برنامه می شود.

بعضی اوقات ، بازاریابان یا مدیران برای برنامه ای اهدافی دارند که در واقع با هدف اصلی برنامه مطابقت ندارد ، مانند &quot;زیبا باشد &quot;  &quot; طراحی بروز داشته باشد&quot; &quot;محبوب رسانه های خبری شود&quot; &quot;از آخرین فناوری ها استفاده شود&quot; و غیره.

این افراد ممکن است برای سازمان شما مهم باشند، اما افرادی نیستند که باید تصمیم بگیرند که برنامه شما چه کاری انجام می دهد! به عنوان یک طراح نرم افزار یا مدیر فنی، وظیفه شما این است که ببینید برنامه در مسیر خود قرار دارد و هرگز هدف اصلی خود را نقض نمی کند. هیچ کس دیگری مسئولیت آن را بر عهده نخواهد گرفت. گاهی اوقات ممکن است واقعاً مجبور شوید برای آن بجنگید، اما در طولانی مدت ارزشش را دارد.

و اینطور نیست که شما با این فلسفه به یک شکست بازاریابی رسیده‌اید. محصولات بسیار بسیار زیادی وجود دارند که تنها با رعایت یک هدف ، بسیار موفق بوده اند. هدف صابون فقط تمیز کردن است. هدف نمک شور کردن است .یک لامپ فقط اتاق را روشن می کند. اما همه اینها محصولاتی هستند که طی دهه ها از شرکت های عظیم حمایت کرده اند. برای داشتن بازاریابی موثر نیازی به داشتن محصول پیچیده نیست. شما فقط باید در بازاریابی دانش و مهارت داشته باشید که یک زمینه کاملاً جدا از طراحی نرم افزار است. واقعاً ، نیازی به تجملات و پیچیدگی و سعی برای  انجام 500 کار همزمان در یک برنامه وجود ندارد. کاربران با یک محصول متمرکز و ساده که هرگز هدف اساسی خود را نقض نمی کند خوشحال هستند.

**فناوری های بد**

یکی دیگر از منابع متداول پیچیدگی ، انتخاب فناوری نادرست برای استفاده در سیستم شماست - خصوصاً یکی از فناوری هایی که در نهایت نمی تواند نیازهای آینده را تحمل کند. با این حال ، بدون اینکه بتوانید آینده را پیش بینی کنید ، اکنون چه فناوری را انتخاب کنید ، می تواند مشکل باشد. خوشبختانه ، سه عامل وجود دارد که می توانید برای تعیین &quot;بد&quot; بودن فناوری قبل از شروع استفاده از آن بررسی کنید: پتانسیل بقا، قابلیت همکاری و توجه به کیفیت.

**پتانسیل بقا**

پتانسیل بقای یک فناوری احتمال ادامه کار آن است. اگر در یک کتابخانه منسوخ شده باشید، واقعاً دچار مشکل خواهید شد.

با نگاهی به تاریخچه انتشار اخیر آن، می توانید از پتانسیل زنده ماندن یک نرم افزار مطلع شوید. آیا توسعه دهندگان مرتباً با نسخه های جدیدی که مشکلات واقعی کاربران را برطرف می کند ، ارائه میکنند؟ همچنین ، توسعه دهندگان چقدر به گزارشات اشکالات پاسخ می دهند؟ آیا آنها ایمیل لیست یا تیم پشتیبانی بسیار فعال دارند؟ آیا افراد آنلاین زیادی در مورد این فناوری صحبت می کنند؟ اگر اکنون یک فناوری تحرک زیادی دارد ، می توانید مطمئن باشید که به زودی نمی میرد.

همچنین بررسی کنید که آیا فقط یک فروشنده از آن فن آوری پشتیبانی میکند یا اینکه به طور گسترده ای در بسیاری از زمینه های نرم افزار توسط بسیاری از توسعه دهندگان مختلف پذیرفته شده است. اگر فقط یک فروشنده وجود داشته باشد که سیستم را پشتیبانی میکند و به جلو می فرستد، این خطر وجود دارد که آن فروشنده یا از کار خارج شود یا فقط تصمیم به حفظ و ادامه سیستم بگیرد.

**محبوبیت**

ممکن است به نظر برسد که ما می گوییم شما فقط باید محبوب ترین فناوری را متناسب با نیازهای خود انتخاب کنید. تا حدی ، این درست است - فن آوری های محبوب دارای پتانسیل زنده ماندن زیادی هستند. با این حال ، شما باید تفاوت بین ابزارهای معتبر محبوب و ابزارهای محبوب فقط به دلیل داشتن نوعی انحصار را بررسی کنید.

در زمان نگارش این کتاب، C یکی از نمونه های زبان مشهور معتبری است. بسیاری از افراد از آن در سازمانهای مختلف برای اهداف مختلف استفاده می کنند. این موضوع چندین استاندارد بین المللی است، و تعداد زیادی پیاده سازی از این استانداردها وجود دارد، از جمله کامپایلرهای بسیار پرکاربرد مختلف.

برخی از فناوری ها فقط به این دلیل محبوب هستند که شما باید از آنها استفاده کنید.فرض کنید شرکت X زبان برنامه نویسی خود را طراحی کند. سپس یک دستگاه محبوب را طراحی می کند که فقط برنامه های نوشته شده به آن زبان را می پذیرد. این مورد &quot;یک فروشنده&quot; ذکر شده در متن است - این زبان ممکن است محبوب به نظر برسد ، اما در واقع پتانسیل زنده ماندن ضعیفی دارد ، مگر اینکه به طور گسترده در صنعت نرم افزار مورد استفاده قرار گیرد.

**قابلیت همکاری**

قابلیت همکاری اندازه گیری این است که در صورت لزوم جدا شدن از یک فناوری آسان است. برای اینکه تصوری از قابلیت همکاری یک فناوری داشته باشید، از خود بپرسید ، &quot;آیا می توانیم به روشی استاندارد با این فناوری تعامل داشته باشیم ، بنابراین تغییر سیستم به سیستم دیگری که از همان استاندارد پیروی می کند آسان خواهد بود؟&quot;

به عنوان مثال ، استانداردهای بین المللی برای چگونگی تعامل یک برنامه با سیستم پایگاه داده وجود دارد. برخی از سیستم های پایگاه داده به خوبی از این استانداردها پشتیبانی می کنند. اگر یکی از این سیستم های پایگاه داده خوب را انتخاب کنید ، می توانید در آینده فقط با تغییرات جزئی در برنامه خود به سیستم پایگاه داده دیگری بروید.

با این حال، برخی دیگر از سیستم های پایگاه داده در پشتیبانی از استانداردها مهارت چندانی ندارند. اگر می خواهید بین سیستم های پایگاه داده ای که از استاندارد پشتیبانی نمی کنند جابجا شوید، باید برنامه خود را دوباره بنویسید. بنابراین ، وقتی یکی از این سیستم های غیراستاندارد را انتخاب می کنید ، در آن گیر کرده اید و دیگر نمی توانید به راحتی به سیستم دیگری بروید.

**توجه به کیفیت**

این یکی بیشتر یک اندازه گیری ذهنی است ، اما ایده این است که ببینیم آیا محصول در عرضه های اخیر بهتر شده است یا خیر. اگر می توانید کد منبع را ببینید، بررسی کنید که آیا توسعه دهندگان در حال تجزیه و تحلیل و تمیز کردن کدبیس هستند. آیا استفاده از آن آسانتر شده یا پیچیده تر؟ آیا افرادی که این فناوری را حفظ می کنند در واقع به کیفیت محصول خود اهمیت می دهند؟

**دلایل دیگر**

جنبه های دیگری نیز وجود دارد که باید هنگام انتخاب یک فناوری در نظر بگیرید - در درجه اول سادگی و مناسب بودن آن برای اهداف شما. نظر شخصی نیز می تواند نقشی داشته باشد، بعد از اینکه تمام ملاحظات عملی را در نظر گرفتید. بعضی از افراد شکل ظاهری یک زبان برنامه نویسی را بهتر از زبان دیگر دوست دارند. این گاهی اوقات می تواند یک دلیل معتبر برای انتخاب یک فناوری باشد - اگر شما فقط یک فناوری را بیشتر از فناوری دیگر دوست دارید و هر چیز دیگری بین آنها برابر است، با یکی از ویژگی هایی که شما را خوشحال می کند تکنولوژی خود را انتخاب کنید. از این گذشته، شما کسی هستید که از آن استفاده خواهید کرد - نظر شما مهم است! دستورالعمل های بالا به شما کمک می کند تا گزینه های قطعاً بد را پاک کنید. بقیه به تحقیقات شخصی، نیازها و خواسته های شما بستگی دارد.

**پیچیدگی و راه حل اشتباه**

غالباً ، اگر مشکلی بسیار پیچیده باشد، این بدان معنی است که در طراحی جایی در زیر سطح پیچیدگی، خطایی رخ داده است.

به عنوان مثال، ساخت یک ماشین با سرعت بسیار دشوار است اگر چرخ‌های مربعی داشته باشند. تنظیم موتور مشکلی را حل نمی کند —شما باید ماشین را دوباره طراحی کنید تا چرخ های آن گرد باشد.

هر زمان که در برنامه شما &quot;پیچیدگی غیرقابل حل&quot; وجود داشته باشد، به این دلیل است که اساساً اشکالی در طراحی وجود دارد. اگر مشکل در یک سطح غیر قابل حل به نظر میرسد، به عقب برگردید ببینید چه چیزی ممکن است زمینه ساز این مشکل باشد. برنامه نویسان اغلب این کار را انجام می دهند. ممکن است خودتان را در وضعیتی پیدا کنید که بگویید: &quot;من این کد بسیار نامرتب را دارم و افزودن ویژگی جدید واقعاً پیچیده است!&quot; خوب، مشکل اصلی شما این است که این کد به هم ریخته‌است. آن را مرتب کنید، کد موجود را ساده کنید، و خواهید دید که اضافه کردن ویژگی‌های جدید نیز ساده خواهد بود.

**سعی در حل چه مشکلی دارید؟**

اگر کسی به شما مراجعه کند و چیزی مانند این را بگوید ، &quot;چگونه با یک راکت به ماه بروم ؟&quot; سوالی که باید بپرسید این است که &quot;چه مشکلی دارید که سعی دارید آن را حل کنید؟&quot; ممکن است متوجه شوید آنچه که این شخص واقعاً به آن نیاز دارد جمع آوری برخی از سنگهای خاکستری است. چرا فکر می‌کرد باید به ماه پرواز کند و از یه راکت برای انجام این کار استفاده کند. فقط او ممکن است بداند. مردم اینگونه گیج می شوند. با این حال از آنها بپرسید که برای حل چه مشکلی تلاش می کنند و یک راه حل ساده خود را نشان می دهد. به عنوان مثال ، در این حالت ، هرگاه مسئله را كاملاً فهمیدیم ، راه حل ساده و آشكار می شود: او باید فقط بیرون برود و برخی از سنگهای خاکستری را پیدا کند - نیازی به یک راکت نیست.

بنابراین ، وقتی همه چیز پیچیده شد ، به عقب برگردید و به مشکلی که می خواهید حل کنید، نگاهی بیندازید. یک قدم واقعاً بزرگ به عقب بردارید. شما مجاز هستید همه چیز را زیر سوال ببرید. شاید شما فکر می کردید که اضافه کردن دو و دو, تنها راه برای بدست آوردن چهار است، و به این فکر نکرده اید که یک و سه را اضافه کنید، به طور کامل از اضافه کردن صرف نظر کنید و فقط چهار را در آنجا قرار دهید. مسئله این است، &quot;چگونه شماره چهار را بدست آورم؟&quot;

هر روشی برای حل این مسئله قابل قبول است ، بنابراین آنچه شما باید انجام دهید این است که بفهمید بهترین روش برای شرایطی که در آن قرار دارید چیست.

فرضیات خود را کنار بگذارید. واقعاً به مشکلی که می خواهید حل کنید، نگاه کنید. اطمینان حاصل کنید که تمام جنبه های آن را کاملاً درک کرده اید و سپس ساده ترین راه حل آن را رقم بزنید. نپرسید، &quot;چگونه می توانم با استفاده از کد فعلی خود این مشکل را حل کنم؟&quot; یا &quot;چگونه پروفسور این مشکل را در برنامه خود حل کرد؟&quot; نه — فقط از خود بپرسید، &quot;به طور کلی، در یك جهان كامل، چگونه باید این نوع مشكلات حل شود؟&quot; از آنجا می‌توانید ببینید که چگونه کد شما باید بازسازی شود. سپس می توانید کد خود را دوباره بنویسید. و بعد از آن می توانید مشکل را حل کنید.

**مشکلات پیچیده**

گاهی اوقات از شما خواسته می شود مشکلی را حل کنید که ذاتاً بسیار پیچیده است — به عنوان مثال ، اصلاح هجی کردن، یا کامپیوتری را مجبور کنیم که شطرنج بازی کند. این بدان معنا نیست که راه حل شما باید پیچیده باشد، اما به این معنی است که شما باید هنگام کار با این مشکل بیش از حد معمول کار کنید تا کد خود را ساده کنید.

اگر با یک مشکل پیچیده سروکار دارید، آن را روی کاغذ به زبان ساده بنویسید یا آن را به عنوان نمودار بکشید. بعضی از بهترین برنامه‌ نویسی ها در واقع روی کاغذ انجام می‌شود. قرار دادن آن در کامپیوتر فقط جزئیات کوچک است.

> **اکثر مسائل دشوار  طراحی را میتوان به ساده با کشیدن و یا نوشتن آن‌ها روی کاغذ حل کرد.**

**مدیریت پیچیدگی**

به عنوان یک برنامه نویس، با پیچیدگی روبرو خواهید شد. برنامه نویسان دیگر برنامه های پیچیده ای را می نویسند که باید آنها را برطرف کنید. طراحان سخت افزار و طراحان زبان زندگی شما را دشوار می کنند. اگر بخشی از سیستم شما بیش از حد پیچیده باشد، روش خاصی برای رفع آن وجود دارد - در مراحل کوچک، قطعات جداگانه را دوباره طراحی کنید. هر اصلاح باید به همان اندازه کوچک باشد که با خیال راحت و بدون پیچیدگی بیشتر بتوانید آن را درست کنید. هنگامی که این فرآیند را طی می کنید، بزرگترین خطر این است که با رفع اشکالات خود احتمالاً پیچیدگی بیشتر میشود. به همین دلیل است که در نهایت بسیاری از بازطراحی ها یا بازنویسی ها با شکست روبرو می شوند - آنها پیچیدگی های بیشتری را نسبت به آنچه که رفع می کنند وارد می کنند، یا در نهایت به همان پیچیدگی سیستم اصلی می شوند.

هر مرحله می‌تواند به اندازه دادن یک نام بهتر به یک متغیر یا فقط افزودن چند نظر به کد گیج‌ کننده باشد. اما بیشتر اوقات، این گام‌ها شامل تقسیم یک قطعه پیچیده به چند قطعه ساده است.

به عنوان مثال، اگر یک فایل طولانی دارید که همه کد شما را در بر دارد، با تقسیم یک قطعه کوچک به یک فایل جداگانه، شروع به بهبود آن کنید. سپس طراحی آن قطعه ریز را بهبود ببخشید. سپس قطعه کوچک دیگری از سیستم را به یک پرونده جدید تقسیم کرده و طراحی آن را بهبود بخشید. همین کار را ادامه دهید و در نهایت با یک سیستم قابل اعتماد، قابل فهم و قابل نگهداری مواجه خواهید شد.

توجه به این نکته مهم است که شما نمی توانید نوشتن ویژگی ها را متوقف کنید و مدت طولانی را صرف طراحی مجدد کنید. قانون تغییر به ما می گوید که محیط پیرامون برنامه شما به طور مداوم در حال تغییر است و بنابراین عملکرد برنامه شما باید سازگار باشد. اگر برای مدت زمان قابل توجهی نتوانید از نظر کاربر سازگار شوید و پیشرفت کنید، خطر از دست دادن پایگاه کاربر و مرگ پروژه شما را تهدید می کنید.

خوشبختانه روشهای مختلفی برای ایجاد تعادل در میان این ویژگی نوشتن و کنترل پیچیدگی وجود دارد. یکی از بهترین راه ها این است که طراحی مجدد خود را صرفاً با هدف تسهیل در اجرای برخی ویژگی های خاص و سپس پیاده سازی آن ویژگی انجام دهید. به این ترتیب، شما مرتب بین کار طراحی دوباره و ویژگی جابجا می شوید.

**طراحی مجدد برای یک ویژگی**

پروژه ای به نام Bugzilla تمام داده های خود را در یک پایگاه داده ذخیره می کند. Bugzilla فقط از یک سیستم پایگاه داده خاص برای ذخیره اطلاعات به نام OldDB پشتیبانی می کند. برخی از مشتریان جدید می خواهند از یک سیستم پایگاه داده متفاوت برای ذخیره داده ها به نام NewDB استفاده کنند. این مشتریان دلایل خوبی برای خواستن این ویژگی دارند: آنها NewDB را بسیار بهتر از OldDB می فهمند و از قبل NewDB را در شرکت های خود اجرا می کنند. اما همه مشتریان موجود می خواهند از OldDB استفاده کنند.

بنابراین ، Bugzilla باید پشتیبانی از بیش از یک پایگاه داده را شروع کند. این به تغییرات زیادی در کد نیاز دارد ، زیرا Bugzilla هیچ کد متمرکز برای ذخیره و دریافت اطلاعات از پایگاه داده ندارد. در عوض ، بسیاری از دستورات پایگاه داده سفارشی در سراسر کد وجود دارد که مختص OldDB است و در NewDB کار نمی کند.

یک گزینه این است که دستورات if را در کل پایگاه کد استفاده کنید، نوشتن کد های مختلف برای NewDB و OldDB در همه جا که به پایگاه داده دسترسی پیدا می کند. این تقریباً پیچیدگی کل کدبیس را دو چندان می کند و تیم Bugzilla تنها از چند برنامه نویس نیمه وقت تشکیل شده است. اگر پیچیدگی سیستم دو برابر شود ، دیگر نمی توانند آن را حفظ کنند.

در عوض ، تیم Bugzilla تصمیم به طراحی مجدد سیستم می گیرد تا بتواند از چندین پایگاه داده به راحتی پشتیبانی کند. این یک پروژه عظیم است. در اینجا یک نمای کلی از سطح بالایی از چگونگی انجام آن وجود دارد:

برخی دستورات استاندارد پایگاه داده وجود دارد که روی هر سیستم پایگاه داده کار می کنند ، اما همیشه از آنها استفاده نمی شود. سیستم را مرور کرده و هر بار یک پرونده را درست کنید ، آن را تغییر دهید تا در صورت امکان از دستورات استاندارد استفاده کنید.

برای دستورات پایگاه داده که نسخه استانداردی وجود ندارد ، توابعی ایجاد کنید که دستور درستی را برای پایگاه داده مورد استفاده بازگرداند. یک عملکرد برای یک دستور غیر استاندارد ایجاد می شود و سپس هر نمونه از آن دستور غیر استاندارد با فراخوانی عملکرد جایگزین می شود. این روند را ادامه دهید تا تمام عملکردهای غیر استاندارد از بین بروند.

تعداد زیادی کد به طور کامل در اطراف ویژگی هایی طراحی شده اند که فقط در OldDB وجود دارد. استفاده از این ویژگی های خاص OldDB را متوقف کنید و در عوض از ویژگی های استاندارد استفاده کنید که روی همه سیستم های پایگاه داده کار خواهند کرد. در صورت لزوم در چند مرحله این ویژگی ها را یک به یک برطرف کنید.

طراحی مجدد سیستم نصب Bugzilla به گونه‌ای که بتواند خودش را روی هر سیستم پایگاه‌داده راه‌اندازی کند، نه فقط OldDB. این شامل طراحی مجدد سیستم نصب به ساده‌تر و سپس تنظیم آن کد ساده برای پشتیبانی هم OldDB و هم NewDB است.

هر مرحله بالاتر یک پروژه به خودی خود است. همه آنها به مراحل کوچکتر تقسیم می شوند ، بنابراین می توان روی هر کار طراحی خوبی انجام داد. همچنین ، پس از ایجاد هرگونه تغییر ، سیستم مورد آزمایش قرار می گیرد تا مطمئن شوید که در OldDB همچنان به همان روال قبلی عمل می کند.

آیا این منجر به ایجاد یک سیستم کامل می شود؟ خیر ، اما منجر به سیستمی بهتر از گذشته می شود - علاوه بر پشتیبانی از NewDB ، نگهداری از کد اکنون بسیار آسان تر است. سرانجام Bugzilla برای پشتیبانی از چهار سیستم پایگاه داده مختلف گسترش یافت ، همه به این دلیل که این کار پشتیبانی از سیستم های جدید را بسیار آسان تر می کند.

**ساده تر کردن یک قطعه**

موارد بالا خوب است، اما در واقع برای ساده تر کردن یک قطعه چه کاری انجام می دهید؟ خوب، این جایی است که تمام دانش موجود جهان در مورد طراحی نرم‌افزار به نمایش در می‌آید. این امر به مطالعه در مورد الگوهای طراحی ، روش های مقابله با کد قدیمی و به طور کلی همه ابزارهای مهندسی نرم افزار کمک زیادی می کند. دانستن چندین زبان برنامه نویسی و آشنایی با بسیاری از کتابخانه های مختلف می تواند بسیار مفید باشد، زیرا هر یک شامل روش های مختلف تفکر در مورد مشکلاتی است که می تواند برای شرایط شما قابل اجرا باشد، حتی اگر از آن زبان ها یا کتابخانه ها استفاده نکنید.

مطالعه آن مطالب گزینه های زیادی را برای انتخاب در اختیار شما قرار می دهد در صورتی که با پیچیدگی روبرو هستید. قوانین طراحی نرم افزار می تواند به شما کمک کند گزینه های مناسب را انتخاب کنید و سپس قضاوت و تجربه شما می تواند تعیین کند که واقعاً با مشکل خاص خود چه کاری انجام دهید.

هرگز به صورت ربات وار از یک ابزار صرفا به این دلیل استفاده نکنید زیرا برخی از مقامات آن را بهترین تشخیص داده اند — همیشه کاری که درست است را برای کدی که دارید و وضعیتی که در آن هستید انجام دهید.

با این حال، گاهی ممکن است به یک قطعه کد نگاه کنید و هیچ ابزاری برای ساده کردن آن نداشته باشید. یا ممکن است در برنامه نویسی تازه کار باشید و وقت آن را ندارید که بلافاصله همه این اطلاعات را مطالعه کنید. در این حالت، شما باید فقط به پیچیدگی نگاه کنید و از خودتان بپرسید، &quot;چگونه می توان کار کردن با آن را ساده‌تر و یا بیشتر قابل‌درک کرد؟&quot;  این سوال کلیدی در پشت هر ساده‌سازی است . هر پاسخ واقعی به آن روشی معتبر برای ساده سازی کد شماست.

ابزارها و تکنیک های طراحی نرم افزار فقط به ما کمک می کنند تا پاسخ های بهتری پیدا کنیم.

**پیچیدگی غیر قابل اصلاح**

هنگامی که روی ساده سازی سیستم خود کار می کنید، ممکن است متوجه شوید که جلوگیری از برخی از پیچیدگی ها، مانند پیچیدگی سخت افزار اصلی، دشوار است. اگر با این قبیل با پیچیدگی های غیر قابل اصلاح روبرو شدید ، هدف شما پنهان کردن پیچیدگی است. پوششی اطراف آن قرار دهید که استفاده و درک آن برای سایر برنامه نویسان ساده باشد.

**بازنویسی**

برخی از طراحان ، وقتی با یک سیستم بسیار پیچیده روبرو می شوند، آن را بیرون می اندازند و از نو شروع می کنند.

با این حال ، بازنویسی یک سیستم از پایه اساساً پذیرفتن شکست به عنوان یک طراح است. این بیان میکند که: ما نتوانستیم یک سیستم قابل نگهداری طراحی کنیم و باید از ابتدا شروع کنیم.&quot;

برخی معتقدند که در نهایت همه سیستم ها باید دوباره بازنویسی شوند. این درست نیست. می توان سیستمی را طراحی کرد که هرگز نیازی به دور انداختن نداشته باشد. یک طراح نرم افزار که می گوید &quot;به هر حال باید روزی همه چیز را دور بریزیم&quot; چیزی شبیه یک معمار ساختمان است که می گوید &quot;به هر حال روزی این آسمان خراش سقوط خواهد کرد.&quot;

اگر آسمان خراش ضعیف طراحی شده بود و به خوبی نگهداری نمی شد، بله، روزی سقوط می کند. اما اگر از شروع درست ساخته شود و پس از آن به درستی نگهداری شود، چرا باید فرو بریزد؟

ساخت سیستم های نرم افزاری قابل نگهداری همانند ساخت آسمان‌خراش‌های بلند و محکم ممکن است.

اکنون با تمام آنچه گفته شد، شرایطی وجود دارد که بازنویسی در آنها قابل قبول است. با این حال، آنها بسیار نادر هستند. فقط در صورت صحت همه موارد زیر باید دوباره آن را بازنویسی کنید:

1. شما برآورد دقیقی ایجاد کرده اید که نشان می دهد بازنویسی سیستم نسبت به طراحی مجدد سیستم موجود از نظر زمان از بازدهی بیشتری برخوردار است. فقط حدس نزنید — آزمایشات واقعی را با طراحی مجدد سیستم موجود انجام دهید تا ببینید چطور پیش خواهد رفت. مقابله با پیچیدگی موجود و حل بخشی از آن بسیار دشوار است، اما در واقع باید چند بار این کار را انجام دهید تا بدانید که برای رفع مشکل همه آن به چه مقدار تلاش نیاز دارید.

2. شما زمان بسیار زیادی برای صرف یک سیستم جدید اختصاص داده اید.

3. شما به نوعی طراح بهتری نسبت به طراح اصلی سیستم هستید یا اگر طراح اصلی باشید، از زمانی که سیستم اصلی را طراحی کرده اید، مهارت های طراحی شما به شدت بهبود یافته است.

4. شما کاملاً قصد دارید این سیستم جدید را در یک سری مراحل ساده طراحی کنید و کاربرانی داشته باشید که می توانند برای هر مرحله در طول مسیر بازخورد خود را شما ارائه دهند.

5. منابع در دسترس شماست تا هم سیستم موجود را حفظ کنید و هم سیستم جدیدی را همزمان طراحی کنید. هرگز نگهداری سیستمی را که اکنون در حال استفاده است متوقف نکنید تا برنامه نویسان بتوانند آن را دوباره بنویسند.

در صورت استفاده, سیستم ها باید همیشه نگهداری شوند. و به یاد داشته باشید که توجه شخصی شما نیز یک منبع است &quot;که باید در اینجا مورد توجه قرار گیرد اگر قرار است روی هر دو کار کنید آیا هر روز وقت کافی دارید که بتوانید به طور همزمان طراح سیستم جدید و سیستم قدیمی باشید ؟

اگر تمام نکات فوق صحیح باشد ، ممکن است در شرایطی قرار بگیرید که بازنویسی قابل قبول باشد. در غیر این صورت، کار صحیح این است که پیچیدگی سیستم موجود را با بهبود طراحی سیستم در یک سری مراحل ساده بدون بازنویسی کنترل کنید.