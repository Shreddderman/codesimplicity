<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>تغییر | سادگی کد</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="تغییر" />
<meta name="author" content="محسن محمدی و الیاس سهرابی" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="اکنون که اهمیت آینده را فهمیدیم و فهمیدیم مواردی وجود دارد که نمی دانیم و نمی توانیم در مورد آن بدانیم، چه چیزی را می توان در مورد آینده فهمید؟ خوب ، یک چیزی که می توانید از آن اطمینان داشته باشید این است که با گذشت زمان ، محیط نرم افزار شما تغییر می کند. هیچ چیز برای همیشه ثابت نمی ماند. این بدان معنی است که نرم افزار شما باید تغییر کند تا بتواند خود را با محیط اطراف سازگار کند." />
<meta property="og:description" content="اکنون که اهمیت آینده را فهمیدیم و فهمیدیم مواردی وجود دارد که نمی دانیم و نمی توانیم در مورد آن بدانیم، چه چیزی را می توان در مورد آینده فهمید؟ خوب ، یک چیزی که می توانید از آن اطمینان داشته باشید این است که با گذشت زمان ، محیط نرم افزار شما تغییر می کند. هیچ چیز برای همیشه ثابت نمی ماند. این بدان معنی است که نرم افزار شما باید تغییر کند تا بتواند خود را با محیط اطراف سازگار کند." />
<link rel="canonical" href="http://localhost:4000/chapters/6-change.html" />
<meta property="og:url" content="http://localhost:4000/chapters/6-change.html" />
<meta property="og:site_name" content="سادگی کد" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-04T23:08:25+00:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"محسن محمدی و الیاس سهرابی"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/chapters/6-change.html"},"description":"اکنون که اهمیت آینده را فهمیدیم و فهمیدیم مواردی وجود دارد که نمی دانیم و نمی توانیم در مورد آن بدانیم، چه چیزی را می توان در مورد آینده فهمید؟ خوب ، یک چیزی که می توانید از آن اطمینان داشته باشید این است که با گذشت زمان ، محیط نرم افزار شما تغییر می کند. هیچ چیز برای همیشه ثابت نمی ماند. این بدان معنی است که نرم افزار شما باید تغییر کند تا بتواند خود را با محیط اطراف سازگار کند.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/siteicon.png"},"name":"محسن محمدی و الیاس سهرابی"},"@type":"BlogPosting","url":"http://localhost:4000/chapters/6-change.html","headline":"تغییر","dateModified":"2021-02-04T23:08:25+00:00","datePublished":"2021-02-04T23:08:25+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


		<link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic" rel="stylesheet">
		<link rel="stylesheet" media="print" href="/css/print.css">
		<link rel="stylesheet" media="screen" href="/css/screen.css">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		
	</head>
	<body>
		<div class="cover" >
			<div class="wrap">
				<div class="book">
					<div class="front-cover" style="background-image: url(/images/cover.jpg)">
						<div class="cover-content" style="background-color: #00000096 !important; border-radius:5px; padding: 2px 20px 4px 20px;">
							<h1>سادگی کد</h1>
							<p class="author" style="color:#fff; filter: brightness(200%); font-size: 1.6em;">
								ترجمه:
								<br/>
								محسن محمدی و الیاس سهرابی
							</p>
						</div>
					</div>
					<ul class="ruled_paper">
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
					<div class="back-cover"></div>
				</div>
				<div class="pdf-cover">
					<h1>سادگی کد</h1>
					<p class="author">ترجمه: محسن محمدی و الیاس سهرابی</p>
				</div>
			</div>
			<img src="/images/cover.jpg" class="background">
		</div>

		<p class="wrap formats">
				<a class="active" href="/">تمام صفحه</a>
			&#183;
				<a  href="/full.html">نسخه html</a>
			&#183;
				<a href="/full.html#print-book">پرینت</a>
		</p>

		<div class="wrap">
	

	
<h3 id="toc">فهرست کتاب</h3>
<ul class="toc">
	
	
		<li>
	
		<a href="/chapters/1-preface.html#مقدمه">1. مقدمه</a>
	

</li>
	
		<li>
	
		<a href="/chapters/2-introduction.html#معرفی">2. معرفی</a>
	

</li>
	
		<li>
	
		<a href="/chapters/3-the-missing-science.html#علم-گمشده">3. علم گمشده</a>
	

</li>
	
		<li>
	
		<a href="/chapters/4-the-driving-forces-of-software-design.html#نیرو-های-محرک-طراحی-نرم-افزار">4. نیرو های محرک طراحی نرم افزار</a>
	

</li>
	
		<li>
	
		<a href="/chapters/5-the-future.html#آینده">5. آینده</a>
	

</li>
	
		<li>
	
		<a class="active" href="/chapters/6-change.html#تغییر">6. تغییر</a>
	

</li>
	
		<li>
	
		<a href="/chapters/7-defects-and-design.html#نقص-ها-و-طراحی">7. نقص ها و طراحی</a>
	

</li>
	
		<li>
	
		<a href="/chapters/8-Simplicity.html#سادگی">8. سادگی</a>
	

</li>
	
		<li>
	
		<a href="/chapters/9-complexity.html#پیچیدگی">9. پیچیدگی</a>
	

</li>
	
		<li>
	
		<a href="/chapters/10-testing.html#آزمایش-کردن">10. آزمایش کردن</a>
	

</li>
	
		<li>
	
		<a href="/chapters/11-appendix-a.html#پیوست-اول">11. پیوست اول</a>
	

</li>
	
		<li>
	
		<a href="/chapters/12-appendix-b.html#پیوست-دوم">12. پیوست دوم</a>
	

</li>
	
</ul>


</div>

<div class="content">
	<div class="wrap">
		<h2 id="تغییر"><span class="chapter-number">فصل 6</span> تغییر</h2>
<p class="editor-link"><a href="cloudcannon:collections/_chapters/6-change.md" class="btn"><strong>&#9998;</strong> Edit Chapter 6</a></p>
<p>اکنون که اهمیت آینده را فهمیدیم و فهمیدیم مواردی وجود دارد که نمی دانیم و نمی توانیم در مورد آن بدانیم، چه چیزی را می توان در مورد آینده فهمید؟ خوب ، یک چیزی که می توانید از آن اطمینان داشته باشید این است که با گذشت زمان ، محیط نرم افزار شما تغییر می کند. هیچ چیز برای همیشه ثابت نمی ماند. این بدان معنی است که نرم افزار شما باید تغییر کند تا بتواند خود را با محیط اطراف سازگار کند.</p>

<p>این ما را قانون تغییر می رساند:</p>

<blockquote>
  <p><strong>هرچه برنامه شما برای مدت طولانی‌تری فعال باشد، احتمال تغییر در هر قطعه از آن بیشتر میشود.</strong></p>
</blockquote>

<p>در حالی که بسوی آینده بی‌نهایت می‌روید، به سمت یک احتمال ۱۰۰ % می‌روید که هر قطعه از برنامه شما باید تغییر کند. پنج دقیقه بعد احتمالا هیچ بخشی از برنامه شما تغییر نخواهد کرد.در 10 روز آینده ، ممکن است قطعه کوچکی از آن تغییر کند. در 20 سال آینده، احتمالاً اکثریت آن (اگر نه همه آن) باید تغییر کند.</p>

<p>پیش بینی اینکه در آينده دقیقاً چه چیزی تغییر خواهد کرد دشوار است. شاید شما برنامه ای برای اتومبیل های 4 چرخ نوشتید، اما شاید در آینده همه با کامیون های 18 چرخ رانندگی کنند. شاید شما برنامه ای برای دانش آموزان دبیرستان نوشتید، اما تحصیلات دبیرستان چنان بد خواهد شد که دانش آموزان دیگر نمی توانند آن را درک کنند.</p>

<p>نکته این است که لازم نیست سعی کنید که پیش‌بینی کنید چه چیزی تغییر خواهد کرد؛ شما فقط باید بدانید که همه چیز تغییر خواهد کرد. نرم‌افزار خود را بنویسید به طوری که تا حد معقول انعطاف‌پذیر باشد، و شما قادر خواهید بود با هر نوع تغییرات آتی سازگار شوید.</p>

<p><strong>تغییر در یک برنامه دنیای واقعی</strong></p>

<p>بیایید برخی از داده ها را در مورد چگونگی تغییر یک برنامه دنیای واقعی با گذشت زمان بررسی کنیم. صدها فایل در این برنامه خاص وجود دارد، اما جزئیات هر پرونده در این صفحه نمی گنجد ، بنابراین چهار فایل به عنوان نمونه انتخاب شده است. جزئیات مربوط به این پرونده ها در جدول 5-1 آورده شده است.</p>

<p>جدول 5-1. تغییر در فایل ها با گذشت زمان</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
    <tr>
      <th>فایل <strong>1</strong></th>
      <th>فایل <strong>2</strong></th>
      <th>فایل <strong>3</strong></th>
      <th>فایل <strong>4</strong></th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>دوره آنالیز شده</td>
      <td>5سال / 2ماه</td>
      <td>8سال/ 3 ماه</td>
      <td>13 سال / 3 ماه</td>
      <td>13 سال / 4 ماه</td>
    </tr>
    <tr>
      <td>خطهای نوشته شده</td>
      <td>423</td>
      <td>192</td>
      <td>227</td>
      <td>309</td>
    </tr>
    <tr>
      <td>خطهای بدون تغییر</td>
      <td>271</td>
      <td>101</td>
      <td>4</td>
      <td>8</td>
    </tr>
    <tr>
      <td>خطهای موجود</td>
      <td>664</td>
      <td>948</td>
      <td>388</td>
      <td>414</td>
    </tr>
    <tr>
      <td>مقدار رشد</td>
      <td>241</td>
      <td>756</td>
      <td>161</td>
      <td>105</td>
    </tr>
    <tr>
      <td>تعدا دفعات تغییر</td>
      <td>47</td>
      <td>99</td>
      <td>194</td>
      <td>459</td>
    </tr>
    <tr>
      <td>خط های اضافه شده</td>
      <td>396</td>
      <td>1,026</td>
      <td>913</td>
      <td>3,828</td>
    </tr>
    <tr>
      <td>خط های حذف شد</td>
      <td>155</td>
      <td>270</td>
      <td>752</td>
      <td>3,723</td>
    </tr>
    <tr>
      <td>خط های اصلاح شده</td>
      <td>124</td>
      <td>413</td>
      <td>1,382</td>
      <td>3,556</td>
    </tr>
    <tr>
      <td>کل تغییرات</td>
      <td>675</td>
      <td>1,709</td>
      <td>3,047</td>
      <td>11,107</td>
    </tr>
    <tr>
      <td>نسبت تغییر</td>
      <td>1.6x</td>
      <td>8.9x</td>
      <td>13x</td>
      <td>36x</td>
    </tr>
  </tbody>
</table>

<p>در این جدول:</p>

<p>دوره آنالیز شده</p>

<blockquote>
  <p>دوره زمانی که فایل وجود داشته است.</p>
</blockquote>

<p>خط های اصلی</p>

<blockquote>
  <p>چه تعداد خط در فایل وجود داشته که در ابتدا نوشته شده است.</p>
</blockquote>

<p>خط های بدون تغییر</p>

<blockquote>
  <p>چند خط از ابتدا تا به حال ثابت مانده است.</p>
</blockquote>

<p>خط های موجود</p>

<blockquote>
  <p><em>در پایان دوره تجزیه و تحلیل ، اکنون چند خط در فایل وجود دارد.</em></p>
</blockquote>

<p>مقدار رشد</p>

<blockquote>
  <p>تفاوت بین "خط های اصلی" و "خط های موجود"</p>
</blockquote>

<p>تعداد دفعات تغییر</p>

<blockquote>
  <p>تعداد کل دفعاتی که یک برنامه نویس مجموعه ای از تغییرات را در پرونده ایجاد کرده است (جایی که یک مجموعه از تغییرات شامل تغییر در بسیاری از خطوط است). معمولاً یک مجموعه تغییرات نمایانگر یک رفع اشکال ، یک ویژگی جدید و غیره است.</p>
</blockquote>

<p>خط های اضافه شده</p>

<blockquote>
  <p>چند بار، در طول تاریخ فایل، یک خط جدید اضافه شد.</p>
</blockquote>

<p>خط های حذف شد</p>

<blockquote>
  <p>چند بار، در طول تاریخ فایل، یک خط موجود حذف شده است.</p>
</blockquote>

<p>خط های اصلاح شده</p>

<blockquote>
  <p>چند بار، در طول تاریخ پرونده، یک خط موجود تغییر داده شده است (اما اخیراً اضافه نشده یا حذف نشده است).</p>
</blockquote>

<p>کل تغییرات</p>

<blockquote>
  <p>مجموع "خطوط اضافه شده" ، "خطوط حذف شده" و "خطوط اصلاح شده" برای آن پرونده به حساب می آید.</p>
</blockquote>

<p>نسبت تغییر</p>
<blockquote>
  <p>“تغییرات کلی” چقدر بزرگ‌تر از “خطوط اصلی” هستند.</p>
</blockquote>

<p>هنگامی که ما در توضیحات بالا به "خطوط" مراجعه می کنیم، این شامل هر سطر در فایل ها است: کد، نظرات، مستندات و خطوط خالی. اگر بخواهید تجزیه و تحلیل را بدون شمارش نظرات ، مستندات و خطوط خالی انجام دهید ، تفاوت عمده ای که مشاهده خواهید کرد این است که تعداد "خطوط بدون تغییر" به نسبت تعداد دیگر بسیار کوچکتر خواهد شد. (به عبارت دیگر ، خطوط بدون تغییر تقریباً همیشه نظرات ، مستندات یا خطوط خالی هستند).</p>

<p>مهمترین چیزی که از این جدول باید فهمید این است که تغییرات زیادی در یک پروژه نرم افزاری اتفاق می افتد. با گذشت زمان بیشتر و بیشتر احتمال دارد که هر خط خاصی از کد تغییر کند، اما شما نمی توانید دقیقاً پیش بینی کنید چه چیزی تغییر می کند، چه زمانی تغییر می کند یا اینکه چه مقدار باید تغییر کند. هر یک از این چهار فایل به روش‌های بسیار متفاوتی تغییر کرده‌است (شما می‌توانید این را ببینید)، اما همه آن‌ها مقدار قابل‌توجهی تغییر کرده اند.</p>

<p>چیزهای جالب دیگری هم در مورد اعداد وجود دارد، مانند:</p>

<ul>
  <li>
    <p>با نگاهی به مقیاس تغییر، می بینیم که برای تغییر هر پرونده بیشتر از نوشتن آن کار شده است. بدیهی است که شمارش خط برآورد کاملی از میزان واقعی کار نیست ، اما درک کلی به ما می دهد. گاهی اوقات نسبت تغییر بسیار زیاد است - به عنوان مثال، فایل 4 ، 36 برابر بیشتر از خطوط اصلی تغییر داشته است.</p>
  </li>
  <li>
    <p>تعداد خطوط تغییر یافته در هر پرونده در مقایسه با تعداد "خطوط اصلی" آن کم و در مقایسه با تعداد "خطوط اکنون" آن حتی کمتر است.</p>
  </li>
  <li>تغییرات زیادی می تواند برای یک فایل اتفاق بیفتد حتی اگر با گذشت زمان فقط کمی بزرگتر شود. به عنوان مثال ، پرونده 3 در طول 13 سال فقط 161 خط رشد کرد ، اما در طول آن تعداد کل تغییرات به 3047 خط رسید.</li>
  <li>
    <p>تعداد کل شمارش همیشه بزرگ‌تر از تعداد خطوط در حال حاضر است. به عبارت دیگر، احتمال تغییر یک خط در یک فایل بیشتر از نگهداری و داشتن آن خط است، به خصوص زمانی که فایل برای مدت طولانی موجود باشد.</p>
  </li>
  <li>در پرونده 3 ، تعداد خطوط اصلاح شده بیشتر از تعداد خطوط موجود در فایل اصلی به علاوه تعداد خطوط اضافه شده است. خطوط آن پرونده بیشتر از اضافه شدن خطوط جدید اصلاح شده است. به عبارت دیگر ، برخی از سطرهای آن پرونده بارها و بارها تغییر کرده اند. این در پروژه هایی با طول عمر طولانی معمول است.</li>
</ul>

<p>نکات فوق همه مواردی نیست که می توان در اینجا آموخت - تجزیه و تحلیل بسیار جالب تری وجود دارد که می توان روی این اعداد انجام داد. به شما توصیه می شود این داده ها را جستجو کنید (یا اعداد مشابهی را برای پروژه خود بسازید) و ببینید چه چیزهای دیگری می توانید یاد بگیرید.</p>

<blockquote>
  <p>☆یک تجربه یادگیری خوب دیگر، مرور تاریخچه تغییرات ایجاد شده در یک فایل خاص است. اگر سابقه هر تغییر در فایل ها را در برنامه خود ثبت کرده اید و یک فایل دارید که مدت هاست وجود ندارد ، سعی کنید هر تغییری را که در طول عمر آن انجام شده است ، مشاهده کنید. به این فکر کنید که آیا هنگام نوشتن پرونده می توانستید آن تغییر را پیش بینی کنید یا خیر و در نظر بگیرید که آیا برای ساده تر شدن تغییرات می توان فایل را در ابتدا بهتر نوشت؟ به طور کلی، سعی کنید هر تغییری را درک کنید و ببینید آیا می توانید با این کار چیز جدیدی در مورد توسعه نرم افزار یاد بگیرید.</p>
</blockquote>

<p><strong>سه نقص</strong></p>

<p>سه اشتباه گسترده وجود دارد که طراحان نرم افزار هنگام تلاش برای کنار آمدن با قانون تغییر مرتکب می شوند، که به ترتیب میزان شایع بودن آنها در اینجا ذکر شده است:</p>

<ol>
  <li>
    <p>نوشتن کدی که مورد نیاز نیست</p>
  </li>
  <li>
    <p>آسان نساختن کد برای تغییر</p>
  </li>
  <li>
    <p>بیش از حد عام بودن</p>
  </li>
</ol>

<p><strong>نوشتن کدی که مورد نیاز نیست</strong></p>

<p>امروزه یک قانون مشهور در طراحی نرم افزار وجود دارد به نام "You Ain't Gonna Need It" یا به اختصار YAGNI. اساساً ، این قانون بیان می کند که شما نباید کد را قبل از نیاز واقعی آن بنویسید. این یک قانون خوب است ، اما نامش اشتباه است. در واقع ممکن است در آینده به کد نیاز داشته باشید ، اما از آنجا که نمی توانید آینده را پیش بینی کنید ، هنوز نمی دانید که کد باید چگونه کار کند. اگر هم اکنون آن را بنویسید، قبل از اینکه به آن احتیاج داشته باشید ، مجبور خواهید شد که برای استفاده واقعی آن را دوباره طراحی کنید. بنابراین در زمان طراحی مجدد خود صرفه جویی کنید و به راحتی صبر کنید تا قبل از نوشتن کد ، به آن نیاز پیدا کنید.</p>

<p>خطر دیگر نوشتن کد قبل از نیاز داشتن به آن کد این است که کد استفاده نشده تمایل به ایجاد "پوسیدگی بیت" دارد. از آنجا که کد هرگز اجرا نمی شود ، ممکن است به آرامی با بقیه سیستم شما همگام شود و در نتیجه اشکال ایجاد کند، و شما هرگز نخواهید فهمید. سپس ، وقتی شروع به استفاده از آن کردید ، باید وقت خود را برای رفع اشکال آن صرف کنید. یا حتی بدتر ، ممکن است به کدی که قبلاً استفاده نشده اعتماد داشته باشید و آن را بررسی نکنید و ممکن است برای کاربران اشکال ایجاد کند. در واقع ، این قانون در اینجا باید گسترش یابد و به شرح زیر باشد:</p>

<blockquote>
  <p><strong>کد را تا زمانی که واقعاً به آن احتیاج ندارید، ننویسید و کدی را که استفاده نمی شود حذف کنید.</strong></p>
</blockquote>

<p>یعنی شما همچنین باید از هر کدی که دیگر نیازی به آن نیست خلاص شوید. در صورت نیاز مجدد ، می توانید همیشه بعداً آن را اضافه کنید.</p>

<p>دلایل زیادی وجود دارد که مردم فکر می کنند باید کدها را قبل از اینکه لازم باشد بنویسند، یا کدی را که استفاده نمی شود نگه دارند. اول از همه ، برخی از مردم معتقدند که می توانند با برنامه نویسی هر ویژگی که ممکن است کاربر به آن نیاز داشته باشد، قانون تغییر را دور بزنند. سپس ، آنها فکر می کنند که در آینده برنامه نباید تغییر کند یا بهبود یابد. اما این اشتباه است. نوشتن سیستمی که هرگز تغییر نخواهد کرد ، تا زمانی که این سیستم به کاربران خود خدمات ارائه دهد ، امکان پذیر نیست.</p>

<p>برخی دیگر بر این باورند که با انجام کار بیشتر در حال حاضر خود را در آینده نجات میدهند. در برخی موارد، این فلسفه کار می‌کند، اما نه وقتی که در حال نوشتن کد هستید که مورد نیاز نیست. حتی اگر این کد در آینده مورد نیاز باشد، شما قطعا باید وقت خود را برای طراحی مجدد آن صرف کنید، پس واقعا دارید زمان را هدر می‌دهید.</p>

<h2 id="نوشتن-کد-غیر-ضروری--یک-مثال-از-دنیای-واقعی">نوشتن کد غیر ضروری : یک مثال از دنیای واقعی</h2>

<p>روزگاری ، یک توسعه دهنده - بیایید او را Max بنامیم - به اشتباه تصور کرد که می تواند این قانون را نادیده بگیرد. در برنامه وی جعبه های کشویی وجود داشت که کاربران می توانستند مقداری را انتخاب کنند . هر شرکتی که از این برنامه استفاده می کند می تواند لیستی از گزینه های نمایش داده شده در هر کادر کشویی را شخصی سازی کند. برخی از شرکت ها ممکن است بخواهند انتخاب ها نام رنگها باشد. دیگران ممکن است بخواهند آنها نام شهرها باشند. آنها می توانند هر چیزی باشند. بنابراین، لیست گزینه های معتبر باید جایی ذخیره شود که هر شرکت بتواند آن را اصلاح کند.</p>

<p>کار واضحی که باید انجام شود فقط ذخیره کردن لیست مقادیر بود. به هر حال ، این تنها چیزی است که لازم بود. اما ماکس تصمیم گرفت دو چیز را ذخیره کند: لیست مقادیر ، و همچنین اطلاعاتی درباره اینکه آیا هر مقدار در حال حاضر "فعال" است - یعنی اگر کاربران در حال حاضر می توانند آن مقدار را انتخاب کنند یا به طور موقت غیرفعال شده است.</p>

<p>با این حال، ماکس هیچ برنامه‌ای برای استفاده از اطلاعات در مورد این که آیا هر حوزه فعال است یا خیر، ننوشته است. تمام انتخاب‌ها فعال بودند، تمام مدت، صرف‌نظر از آنچه که داده‌های ذخیره‌شده بیان می‌کردند. او مطمئن بود که در شرف نوشتن یک کد برای استفاده از اطلاعات "فعال" است.</p>

<p>چندین سال گذشت و کدی برای مدیریت داده های "فعال" نوشته نشد. در عوض ، داده ها فقط در آنجا ثبت شده بودند ، و برای کاربران گیج کننده بودند و اشکال ایجاد می کردند. بسیاری از مشتریان و توسعه دهندگان برای مکس نوشتند که چرا هیچ اتفاقی نیفتاده است زیرا آنها لیستی از مقادیر را به صورت دستی ویرایش می کنند و گزینه های غیرفعال را تنظیم می کنند. یکی از توسعه دهندگان به نادرست تصور کرد که قسمت "فعال" در حال استفاده است و کدی را نوشت که از آن استفاده می کند ، حتی اگر بقیه سیستم از آن استفاده نکرده باشند. این موضوع به مشتری منتقل شد و آنها شروع به گزارش اشکالات عجیبی کردند که برای ردیابی آنها کار زیادی لازم بود.</p>

<p>سرانجام، برخی از توسعه دهندگان آمدند و گفتند ، "امروز ما توانایی غیرفعال کردن گزینه ها را اجرا خواهیم کرد!" با این حال ، آنها کشف کردند که فیلد "فعال" کاملاً متناسب با نیازهای آنها طراحی نشده است ، بنابراین آنها مجبور شدند برای اجرای ویژگی خودشان کمی طراحی مجدد انجام دهند.</p>

<p>نتیجه: چندین اشکال ، گیجی زیاد و کارهای اضافی برای توسعه دهنده ای که در نهایت واقعاً به کد احتیاج داشت. و این یک تخلف نسبتاً جزئی از قانون بود! تخلفات شدید می تواند عواقب قابل ملاحظه ای بدتر از جمله مهلت های از دست رفته ، فاجعه های بزرگ و حتی احتمالاً تخریب پروژه نرم افزاری شما به همراه داشته باشد.</p>

<p>نتیجه خالص: چندین اشکال ، گیجی زیاد و کارهای اضافی,همه برای توسعه دهنده ای که در نهایت واقعاً به کد احتیاج داشت. و این یک تخلف نسبتاً جزئی از قانون بود! تخلفات شدید می تواند عواقب بدتر قابل ملاحظه ای از جمله مهلت های از دست رفته ، فاجعه های بزرگ و حتی احتمالاً تخریب پروژه نرم افزاری شما به همراه داشته باشد.</p>

<p><strong>آسان نکردن کد برای تغییر</strong></p>

<p>یکی از قاتلین بزرگ پروژه‌های نرم‌افزاری، چیزی است که ما آن را "طراحی سخت" می‌نامیم. دو راه برای به دست آوردن یک طرح سخت وجود دارد :</p>

<ol>
  <li>
    <p>فرضیات بسیار زیادی در مورد آینده داشته باشید.</p>
  </li>
  <li>
    <p>کد را بدون طراحی کافی بنویسید.</p>
  </li>
</ol>

<h2 id="مثال--ایجاد-فرضیات-بسیار-در-مورد-آینده">مثال : ایجاد فرضیات بسیار در مورد آینده</h2>

<p>یک اداره دولتی - اجازه دهید آن را بیمارستان بنامیم - می‌خواهد یک برنامه بسازد . ما این برنامه را "سیستم بهداشتی" می نامیم. قبل از ساخت این سیستم ، دولت تصمیم می گیرد سندی بنویسد که دقیقاً نحوه اجرای کل سیستم را بیان کند. یک سال را صرف نوشتن این سند می‌کند و هر تصمیم واحدی را در مورد کل سیستم در طول این زمان می‌گیرد.</p>

<p>سپس توسعه دهندگان سه سال را صرف نوشتن سیستم طبق این سند می کنند. وقتی کار می کنن ، می فهمند که طرح موجود در سند متناقض و ناقص است و سخت اجرا می شود. اما یک سال تمام طول کشید تا نوشته شود - توسعه دهندگان نمی‌توانند یک سال دیگر صبر کنند تا آن را بازبینی کنند. پس آن‌ها سیستم را اجرا می‌کنند و تا آنجا که می‌توانند از سند پیروی می‌کنند. سیستم تکمیل شده و برای اولین بار در اختیار کاربران قرار می گیرد. با این حال، وضعیت بیمارستان در چهار سال گذشته به طرز چشمگیری تغییر کرده است و هنگامی که کاربران شروع به استفاده از سیستم بهداشت و درمان می کنند، متوجه میشوند که چیزی کاملا متفاوت می خواهند.اما این سیستم از صدها هزار خط کد درست شده‌است که همه با توجه به سند طراحی شده‌اند - بدون ماهها یا سالها تلاش به راحتی قابل تغییر نیست.</p>

<p>بنابراین بیمارستان شروع به نوشتن سند جدیدی برای یک سیستم جدید می کند و روند کار از ابتدا شروع می شود.</p>

<p>اشتباه بیمارستان تلاش برای پیش بینی آینده بود. آنها فرض کردند که هر تصمیمی که در این سند بگیرند برای کاربران واقعی معتبر است و با تکمیل سیستم همچنان معتبر خواهند بود. وقتی آینده واقعی فرا رسید ، اصلاً شبیه آن چیزی نبود که آنها پیش بینی کرده بودند و سیستم آنها یک شکست چند میلیون دلاری بود.</p>

<p>راه حل بهتر این بود که فقط یک ویژگی یا یک مجموعه کوچک از ویژگی ها مشخص شود و بلافاصله از توسعه دهندگان بخواهید آن را پیاده سازی کنند. پس از آن می توانستند هنگام فرآیند توسعه با کاربر ارتباط برقرار کنند و آزمایشات کاربری را اجرا کنند. هنگامی که اولین مجموعه از ویژگی ها اضافه و منتشر شد، آنها می توانستند یکی یکی روی ویژگی های اضافی کار کنند تا اینکه سرانجام سیستمی داشتند که به خوبی طراحی شده بود و کاملاً نیازهای کاربران را تأمین می کرد.</p>

<h2 id="مثال--کد-بدون-طراحی-کافی">مثال : کد بدون طراحی کافی</h2>

<p>از یک توسعه دهنده خواسته می شود تا برنامه ای را ایجاد کند که افراد بتوانند از آن برای پیگیری وظایفی که باید انجام دهند استفاده کنند. برای ایجاد یک "وظیفه" جدید در سیستم ، کاربران یک فرم را با برخی اطلاعات ، مانند خلاصه ای کوتاه از کار و مدت زمان انجام آن ، پر می کنند. این داده ها را در یک پایگاه داده ذخیره می کند. سپس ، آنها می توانند با گذشت زمان در مورد پیشرفت خود در این کار یادداشت برداری کنند و در نهایت یادآوری کنند که کار را به پایان رسانده اند.</p>

<p>فیلدی به نام "وضعیت" وجود دارد که نشان می دهد کاربر در انجام کار چقدر فاصله دارد. مقادیر این قسمت "کار انجام نشده" ، "در حال انجام" ، "در انتظار" و "کامل" است. وقتی قسمت وضعیت دارای مقدار "کار انجام نشده" باشد ، می تواند فقط به "در حال انجام" تغییر کند. وقتی قسمت وضعیت "در حال انجام" است ، می تواند به "در انتظار" یا "کامل" تغییر کند. و وقتی "کامل" باشد ، فقط می تواند به "در حال پیشرفت" تغییر کند.</p>

<p>10 قسمت دیگر در این برنامه با قوانین مشابه وجود دارد. هر کدام از آنها اطلاعات متفاوتی در مورد کار دارند (به عنوان مثال ، اینکه چه کسی تعیین شده است برای این وظیفه، آخرین مهلت آن و غیره).</p>

<p>برای اجرای این قوانین ، توسعه دهنده یک کد بسیار طولانی و مداوم و بدون ساختار را در یک پرونده می نویسد. او هر فیلد را با کد سفارشی که مخصوص آن قسمت است تأیید می کند. به عنوان مثال ، هر بار که نیاز به بررسی وضعیت "کامل" دارد ، وی به معنای واقعی کلمه "کامل" را در کد می نویسد. همچنین، کد برای استفاده مجدد نوشته نشده است. در مواردی که برنامه دارای زمینه های مشابه است ، توسعه دهنده کد را برش می زند و سپس آن را برای قسمت جدید کمی تغییر می دهد.</p>

<p>کد کار می‌کند. این پرونده ۳۰۰۰ خط دارد. تقریبا فاقد یک طرح است.</p>

<p>چندین ماه بعد ، این توسعه دهنده پروژه را ترک می کند.</p>

<p>یک توسعه دهنده جدید آمده و برای حفظ این پروژه به او محول شده است. و به سرعت متوجه می‌شود که تغییر این کدها سخت است - اگر او یک بخش از آن را تغییر دهد، او همچنین باید بسیاری از بخش‌های دیگر را به همان روش تغییر دهد تا کار را ادامه دهد. برای بدتر کردن اوضاع ، قسمت های مختلف بدون توضیح و سیستم منطقی در اطراف پراکنده شده اند - شما باید هر بار که می خواهید تغییری ایجاد کنید ، به راحتی کل فایل را بخوانید.</p>

<p>مشتریان درخواست ویژگی های جدید را شروع می کنند. در ابتدا، توسعه دهنده جدید تمام تلاش خود را برای پیاده سازی این ویژگی های جدید انجام می دهد. وی حتی کد بیشتری به این پرونده اضافه می کند. در نهایت 5000 خط طول دارد.</p>

<p>در نهایت ، مشتریان شروع به درخواست ویژگی هایی می کنند که با این طرح به سادگی قابل اجرا نیست. آنها می خواهند اطلاعات مربوط به وظایف را از طریق ایمیل ارسال کنند ، اما این کد فقط با یک فرم انجام می شود. همه اینها به طور خاص در مورد نحوه کار فرم طراحی شده اند - هرگز با ایمیل کار نمی کنند.</p>

<p>آنها تمام تلاش خود را می کنند تا در هنگام طراحی جدید ، سایر درخواستهای ویژگی را دنبال کنند ، اما بیشتر وقت خود را صرف طراحی مجدد می کنند.</p>

<p>در بخشی از یک برنامه خاص ، کاربر یک فرم را پر کرد و برنامه چند صد ایمیل ارسال کرد. این قسمت از برنامه بسیار کند بود. کاربر فرم را ارسال می کند و برنامه برای مدت زمان طولانی در آنجا می نشیند و تمام پیام ها را می فرستد.</p>

<p>قاعده مورد استفاده برای جلوگیری از طراحی سخت این است:</p>

<blockquote>
  <p><strong>کد باید بر اساس آنچه اکنون می دانید طراحی شود، نه بر اساس آنچه فکر می کنید در آینده اتفاق خواهد افتاد.</strong></p>
</blockquote>

<p>فقط بر اساس نیازهای فوری و شناخته شده تان طراحی کنید، بدون اینکه احتمال نیازهای آینده را کنار بگذارید. اگر به طور حتم می دانید که برای انجام X و فقط X به سیستم نیاز دارید، همین حالا آن را برای انجام X طراحی کنید. این ممکن است کارهای دیگری را در آینده انجام دهد که X نیستند، و شما باید این را در ذهن داشته باشید، اما در حال حاضر سیستم باید فقط X را انجام دهد.</p>

<p>طراحی به این شکل ، به کوچک نگه داشتن تغییرات فردی نیز کمک می کند. وقتی فقط باید یک تغییر کوچک انجام دهید، آسان است که یک طراحی واقعی روی آن انجام دهید.</p>

<p>این بدان معنا نیست که برنامه ریزی بد است. مقدار مشخصی از برنامه ریزی در طراحی نرم افزار بسیار ارزشمند است. اما حتی اگر برنامه های مفصلی را هم ننویسید، تا زمانی که تغییرات شما همیشه کوچک بوده و کد شما به راحتی با آینده ناشناخته سازگار باشد، شما مشکلی نخواهید داشت.</p>

<p><strong>عمومی بودن بیش از حد</strong></p>

<p>هنگامی که با این واقعیت روبرو می شویم که کد آنها در آینده تغییر خواهد کرد، برخی از توسعه دهندگان سعی می کنند با طراحی یک راه حل کاملاً عمومی (به اعتقاد آنها) این مشکل را با هر وضعیت ممکن در آینده تطبیق دهند. ما این را "مهندسی بیش از حد" می نامیم.</p>

<p>فرهنگ لغت مهندسی بیش از حد را ترکیبی از "over" (به معنی "بیش از حد") و "engineer" (به معنی "طراحی و ساخت") تعریف می کند. بنابراین ، از نظر فرهنگ لغت ، این به معنای طراحی یا ساخت بیش از حد مناسب شرایط شما است.</p>

<p>صبر کنید - طراحی یا ساخت بیش از حد ؟ چه چیزی "بیش از حد" است؟ مگر طراحی چیز خوبی نیست؟</p>

<p>خوب ، بله ، بیشتر پروژه ها باید از طراحی بیشتری استفاده کنند، همانطور که در "مثال: کد بدون طراحی کافی" در صفحه 37 دیدیم. اما هر چند وقت یکبار، شخصی به آن می شود زیاده روی میکند- به نوعی مانند ساختن لیزر برای از بین بردن مورچگان است. لیزر یک ابزار مهندسی شگفت انگیز است. اما هزینه آن بسیار زیاد است، ساخت آن بسیار زمانبر و نگهداری آن بسیار سخت است. آیا می توانید تصور کنید که هنگام خراب شدن باید به آنجا بروید و آن را تعمیر کنید؟</p>

<p>مشکلات دیگری هم با (مهندسی بیش از حد)overengineering وجود دارد:</p>

<ol>
  <li>
    <p>شما نمی توانید آینده را پیش بینی کنید ، بنابراین مهم نیست که راه حل شما چقدر عمومی باشد ، آنقدر عمومی نخواهد بود که بتواند نیازهای واقعی آینده را برآورده کند.</p>
  </li>
  <li>
    <p>هنگامی که کد شما بسیار عمومی است ، از نظر کاربر اغلب به خوبی از پس موارد خاصی بر نمی آید. به عنوان مثال، می توان گفت که شما یک کد را طراحی می‌کنید که با تمام ورودی‌های یک‌سان رفتار می‌کند - همه آن‌ها فقط بایت هستند. بعضی اوقات این کد متن را پردازش می کند و گاهی اوقات تصاویر را پردازش می کند ، اما تنها چیزی که می داند این است که بایت دریافت می کند. به نوعی ، این یک طراحی خوب است: کد ساده ، مستقل ، کوچک و غیره است.</p>
  </li>
</ol>

<p>اما سپس مطمئن شوید که هیچ بخشی از کد شما بین تصاویر و متن تفاوت قائل نیست. این خیلی عمومی است. هنگامی که کاربر در یک تصویر بد عبور می کند ، خطایی که دریافت می کند این است: "شما در بایت های بد عبور کردید".باید می گفت: "شما از یک عکس بد عبور کردید" ، اما کد شما آنقدر عمومی است که نمی تواند این موضوع را به کاربر بگوید.</p>

<p>(روش‌های زیادی وجود دارند که یک کده‌ ژنتیکی می‌توانند زمانی کوتاه بیایند که کاربردهای خاص داشته باشند؛ این فقط یک مثال است).</p>

<p>3- خیلی عمومی بودن شامل نوشتن کدهای زیادی است که نیازی نیست ، که ما را به اولین نقص خود بازمی گرداند.</p>

<p>به طور کلی ، وقتی طراحی شما به جای ساده کردن کارها، کارها را پیچیده تر می کند، شما بیش از حد مهندسی می کنید. این لیزر مداری زندگی فردی را که فقط به نابودی برخی مورچه ها احتیاج داشت، بسیار پیچیده می کند، در حالی که برخی از سموم مورچه ساده با از بین بردن مشکل مورچه، زندگی آن شخص را بسیار ساده می کنند (با فرض اینکه موثر باشد).</p>

<p>سخاوت داشتن در موارد درست، با روش های صحیح، می تواند پایه و اساس یک طراحی نرم افزار موفق باشد. با این حال، بیش از حد عمومی بودن می‌تواند علت پیچیدگی ناگفته، سردرگمی و تلاش نگهداری باشد. قانون اجتناب از این عیب شبیه به قانون اجتناب از طرح‌های سخت است:</p>

<blockquote>
  <p><strong>فقط به همان اندازه عمومی باشید که می دانید در حال حاضر لازم است.</strong></p>
</blockquote>

<h2 id="مثال--عمومی-بودن-بیش-از-حد">مثال : عمومی بودن بیش از حد</h2>

<p>در یک برنامه مشخص، کاربر یک فرم را پر می کرد و برنامه صدها ایمیل ارسال کرد. کاربر فرم را ارسال می‌کند و برنامه به مدت بسیار طولانی صبر می کند و سپس همه پیام‌ها را ارسال می‌کند. این قسمت از برنامه خیلی کند است.</p>

<p>برای سریعتر کردن این قسمت، توسعه دهندگان تصمیم گرفتند که بلافاصله همه ایمیل ها را ارسال نکنند. در عوض ، پس از ارسال فرم توسط کاربر، با استفاده از قطعه کد از قبل موجود به نام "ارسال کننده ایمیل" ، آنها در پس زمینه ارسال می شوند.</p>

<p>توسعه دهنده ای که شروع به کار بر روی این تغییر کرد، متوجه شد که برخی از شرکت‌ها ممکن است بخواهند از چیزی غیر از"ارسال کننده ایمیل" استفاده کنند. او صدها خط کد نوشت که به مشتریان امکان می دهد سیستم های دیگر را برای انجام کارهای پس زمینه "وصل" کنند .هیچ مشتری تا به حال این درخواست را نکرده بود. توسعه دهنده پیش‌بینی کرده بود که ممکن است کسی این نوع انعطاف‌پذیری را در آینده بخواهد.</p>

<p>سرانجام معمار اصلی این برنامه بر روی این تغییر کار کرد. او همه کدها را برای "اتصال به سیستم‌های دیگر" را حذف کرد، چون هیچ مدرکی وجود نداشت که کاربران آن را بخواهند. بنابراین، هیچ مدرکی وجود نداشت مبنی بر این که این کد در حال حاضر باید عمومی باشد. با برداشتن آن قطعات کد، این تغییر بسیار ساده‌ تر شد.</p>

<p>چهار سال از زمان تغییر اصلی می گذرد و حتی یک مشتری به توانایی اتصال سایر سیستم ها نیاز نداشته است. در واقع ، هیچ دلیلی برای وجود چنین عمومی وجود نداشت.</p>

<p><strong>توسعه و طراحی افزایشی</strong></p>

<p>روشی برای توسعه نرم افزار وجود دارد که به دلیل ماهیت خود از سه نقص جلوگیری می کند ، به نام "توسعه و طراحی افزایشی". این شامل طراحی و ساخت یک سیستم قطعه قطعه و به ترتیب.</p>

<p>آسان تر است که با مثال توضیح دهید. در اینجا چگونگی استفاده از آن برای توسعه یک برنامه ماشین حساب است که نیاز به جمع ، تفریق ، ضرب و تقسیم دارد:</p>

<ol>
  <li>
    <p>سیستمی را برنامه ریزی کنید که فقط جمع و کار دیگری انجام دهد.</p>
  </li>
  <li>
    <p>آن سیستم را پیاده سازی کنید.</p>
  </li>
  <li>
    <p>طراحی سیستم موجود را برطرف کنید تا افزودن ویژگی تفریق آسان باشد.</p>
  </li>
  <li>
    <p>ویژگی تفریق را در سیستم پیاده سازی کنید. اکنون ما سیستمی داریم که فقط جمع و تفریق را انجام می دهد و نه چیز دیگری.</p>
  </li>
  <li>
    <p>دوباره طراحی سیستم را برطرف کنید تا افزودن ویژگی ضرب آسان باشد.</p>
  </li>
  <li>
    <p>ویژگی ضرب را در سیستم پیاده سازی کنید. اکنون ما سیستمی داریم که جمع ، تفریق ، ضرب و غیره را انجام می دهد.</p>
  </li>
  <li>
    <p>دوباره طراحی سیستم را برطرف کنید تا افزودن ویژگی تقسیم آسان باشد. (در این مرحله ، این کار باید کم یا بدون هیچ کوششی باشد ، زیرا ما قبل از اجرای تفریق و ضرب ، طراحی را بهبود بخشیده ایم)</p>
  </li>
  <li>
    <p>ویژگی تقسیم را در سیستم پیاده سازی کنید. اکنون ما سیستمی را داریم که قصد ساخت آن را داریم ، با طراحی عالی که مناسب آن است.</p>
  </li>
</ol>

<p>این روش توسعه نسبت به برنامه ریزی کل سیستم از قبل و ساخت یک باره، به زمان و تفکر کمتری نیاز دارد. ممکن است در ابتدا اگر به روشهای دیگر توسعه عادت کرده باشید آسان نباشد، اما با تمرین آسان خواهد شد. قسمت جالب استفاده از این روش تصمیم گیری در مورد نحوه اجرای آن است . به طور کلی ، در هر مرحله ، وقتی به آنجا رسیدید ، باید ساده ترین کارها را انتخاب کنید. ما اول جمع را به این دلیل انتخاب کردیم که در کل از بین چهار عمل ساده ترین کار بود، و دوم تفریق برای اینکه بصورت کاملا منطقی بر اساس جمع ساخته شده. ما احتمالاً می توانستیم ضرب را در جایگاه دوم انتخاب کنیم، زیرا ضرب فقط عمل انجام چندین بار جمع است. تنها چیزی که ما نمی توانستیم دوم انتخاب کنیم تقسیم است، زیرا رفتن از جمع به مرحله تقسیم جهش منطقی بزرگی است که بسیار پیچیده است. از طرف دیگر ، رفتن از ضرب به تقسیم در انتها واقعاً بسیار ساده بود ، بنابراین انتخاب خوبی بود.</p>

<p>حتی ممکن است گاهی اوقات لازم باشد که یک ویژگی واحد را بردارید و آن را به بسیاری از مراحل کوچ ، ساده و منطقی تقسیم کنید تا به راحتی قابل اجرا باشد.</p>

<p>این در واقع ترکیبی از دو روش است: یکی به نام "توسعه افزایشی" و دیگری به نام "طراحی افزایشی". توسعه افزایشی روشی است برای ایجاد یک سیستم کامل با کار در قطعات کوچک. در لیست ما ، هر مرحله که با "پیاده سازی" شروع می شد بخشی از روند توسعه افزایشی بود. طراحی افزایشی به همین ترتیب روشی برای ایجاد و بهبود طراحی سیستم در مراحل کوچک است. هر مرحله که با "اصلاح طرح سیستم" یا "طرح" شروع می شد بخشی از روند طراحی افزایشی بود. توسعه و طراحی افزایشی تنها روش معتبر توسعه نرم افزار نیست ، اما روشی است که به طور قطع از سه نقص ذکر شده در بخش قبلی جلوگیری می کند.</p>







	</div>
</div>




		<a href="#toc" class="go-top" style="font-family: Vazir">بازگشت به بالا</a>
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script type="text/javascript" src="/js/main.js"></script>
	</body>
</html>
