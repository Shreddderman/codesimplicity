<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>آینده | سادگی کد</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="آینده" />
<meta name="author" content="محسن محمدی و الیاس سهرابی" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="اولین سوالی که طراحان نرم افزار با آن روبرو هستند این است: &quot;چگونه می توانم در مورد نرم افزارم تصمیم بگیرم؟&quot; وقتی با بسیاری از مسیرهای ممکن مواجه شدید، کدام گزینه بهترین است؟ هرگز این سوال وجود ندارد که کدام تصمیم کاملاً درست است در مقابل کدام تصمیم کاملاً اشتباه است. در عوض ، آنچه می خواهیم بدانیم این است: &quot;با توجه به بسیاری از تصمیمات احتمالی ، کدام یک از این تصمیمات بهتر از دیگران است؟&quot; این مسئله رتبه بندی تصمیمات و سپس انتخاب بهترین تصمیم از بین همه امکانات است." />
<meta property="og:description" content="اولین سوالی که طراحان نرم افزار با آن روبرو هستند این است: &quot;چگونه می توانم در مورد نرم افزارم تصمیم بگیرم؟&quot; وقتی با بسیاری از مسیرهای ممکن مواجه شدید، کدام گزینه بهترین است؟ هرگز این سوال وجود ندارد که کدام تصمیم کاملاً درست است در مقابل کدام تصمیم کاملاً اشتباه است. در عوض ، آنچه می خواهیم بدانیم این است: &quot;با توجه به بسیاری از تصمیمات احتمالی ، کدام یک از این تصمیمات بهتر از دیگران است؟&quot; این مسئله رتبه بندی تصمیمات و سپس انتخاب بهترین تصمیم از بین همه امکانات است." />
<link rel="canonical" href="http://localhost:4000/project/chapters/5-the-future.html" />
<meta property="og:url" content="http://localhost:4000/project/chapters/5-the-future.html" />
<meta property="og:site_name" content="سادگی کد" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-04T23:42:44+00:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"محسن محمدی و الیاس سهرابی"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/project/chapters/5-the-future.html"},"description":"اولین سوالی که طراحان نرم افزار با آن روبرو هستند این است: &quot;چگونه می توانم در مورد نرم افزارم تصمیم بگیرم؟&quot; وقتی با بسیاری از مسیرهای ممکن مواجه شدید، کدام گزینه بهترین است؟ هرگز این سوال وجود ندارد که کدام تصمیم کاملاً درست است در مقابل کدام تصمیم کاملاً اشتباه است. در عوض ، آنچه می خواهیم بدانیم این است: &quot;با توجه به بسیاری از تصمیمات احتمالی ، کدام یک از این تصمیمات بهتر از دیگران است؟&quot; این مسئله رتبه بندی تصمیمات و سپس انتخاب بهترین تصمیم از بین همه امکانات است.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/project/siteicon.png"},"name":"محسن محمدی و الیاس سهرابی"},"@type":"BlogPosting","url":"http://localhost:4000/project/chapters/5-the-future.html","headline":"آینده","dateModified":"2021-02-04T23:42:44+00:00","datePublished":"2021-02-04T23:42:44+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


		<link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic" rel="stylesheet">
		<link rel="stylesheet" media="print" href="/project/css/print.css">
		<link rel="stylesheet" media="screen" href="/project/css/screen.css">
		<link rel="icon" type="image/png" href="/project/images/favicon.png">

		
	</head>
	<body>
		<div class="cover" >
			<div class="wrap">
				<div class="book">
					<div class="front-cover" style="background-image: url(/project/images/cover.jpg)">
						<div class="cover-content" style="background-color: #00000096 !important; border-radius:5px; padding: 2px 20px 4px 20px;">
							<h1>سادگی کد</h1>
							<p class="author" style="color:#fff; filter: brightness(200%); font-size: 1.6em;">
								ترجمه:
								<br/>
								محسن محمدی و الیاس سهرابی
							</p>
						</div>
					</div>
					<ul class="ruled_paper">
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
					<div class="back-cover"></div>
				</div>
				<div class="pdf-cover">
					<h1>سادگی کد</h1>
					<p class="author">ترجمه: محسن محمدی و الیاس سهرابی</p>
				</div>
			</div>
			<img src="/project/images/cover.jpg" class="background">
		</div>

		<p class="wrap formats">
				<a class="active" href="/project/">تمام صفحه</a>
			&#183;
				<a  href="/project/full.html">نسخه html</a>
			&#183;
				<a href="/project/full.html#print-book">پرینت</a>
		</p>

		<div class="wrap">
	

	
<h3 id="toc">فهرست کتاب</h3>
<ul class="toc">
	
	
		<li>
	
		<a href="/project/chapters/1-preface.html#مقدمه">1. مقدمه</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/2-introduction.html#معرفی">2. معرفی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/3-the-missing-science.html#علم-گمشده">3. علم گمشده</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/4-the-driving-forces-of-software-design.html#نیرو-های-محرک-طراحی-نرم-افزار">4. نیرو های محرک طراحی نرم افزار</a>
	

</li>
	
		<li>
	
		<a class="active" href="/project/chapters/5-the-future.html#آینده">5. آینده</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/6-change.html#تغییر">6. تغییر</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/7-defects-and-design.html#نقص-ها-و-طراحی">7. نقص ها و طراحی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/8-Simplicity.html#سادگی">8. سادگی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/9-complexity.html#پیچیدگی">9. پیچیدگی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/10-testing.html#آزمایش-کردن">10. آزمایش کردن</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/11-appendix-a.html#پیوست-اول">11. پیوست اول</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/12-appendix-b.html#پیوست-دوم">12. پیوست دوم</a>
	

</li>
	
</ul>


</div>

<div class="content">
	<div class="wrap">
		<h2 id="آینده"><span class="chapter-number">فصل 5</span> آینده</h2>
<p class="editor-link"><a href="cloudcannon:collections/_chapters/5-the-future.md" class="btn"><strong>&#9998;</strong> Edit Chapter 5</a></p>
<p>اولین سوالی که طراحان نرم افزار با آن روبرو هستند این است: "چگونه می توانم در مورد نرم افزارم تصمیم بگیرم؟" وقتی با بسیاری از مسیرهای ممکن مواجه شدید، کدام گزینه بهترین است؟ هرگز این سوال وجود ندارد که کدام تصمیم کاملاً درست است در مقابل کدام تصمیم کاملاً اشتباه است. در عوض ، آنچه می خواهیم بدانیم این است: "با توجه به بسیاری از تصمیمات احتمالی ، کدام یک از این تصمیمات بهتر از دیگران است؟" این مسئله رتبه بندی تصمیمات و سپس انتخاب بهترین تصمیم از بین همه امکانات است.</p>

<p>به عنوان مثال، یک طراح می‌تواند از خود بپرسید " ۱۰۰ ویژگی متفاوت وجود دارد که ما امروزه می‌توانیم روی آن کار کنیم، اما ما نیروی انسانی داریم که فقط میتواند روی ۲ ویژگی کار کند. کدام یک را باید اول شروع کنیم؟ "</p>

<p><strong>معادله طراحی نرم افزار</strong></p>

<p>سوال فوق و در واقع هر سوال از این ماهیت در طراحی نرم افزار ، با این معادله پاسخ داده می شود:</p>

<p>
 $$ D = \frac{V}{E} $$
</p>
<p>بر این اساس</p>

<p>D</p>

<blockquote>
  <p>این نشانه میزان تمایل به تغییر است. چقدر تمایل به انجام کاری داریم؟</p>
</blockquote>

<p>V</p>

<blockquote>
  <p><em>ارزش یک تغییر است. این تغییر چقدر ارزشمند است؟ معمولاً این را با پرسیدن این که "چقدر به کاربران ما کمک می کند؟" تعیین می کنید. اگرچه روشهای دیگری نیز برای تعیین ارزش وجود دارد.</em></p>
</blockquote>

<p>E</p>

<blockquote>
  <p>نشان دهنده تلاشی است که در اجرای یک تغییر بکار میرود. این تغییر نیازمند چه مقدار تلاش است است؟</p>
</blockquote>

<p>اساساً، این معادله می گوید:</p>

<blockquote>
  <p><strong>مطلوبیت هر تغییر مستقیماً با ارزش تغییر متناسب است و بالعکس با تلاشی که در ایجاد تغییر انجام می شود متناسب است.</strong></p>
</blockquote>

<p>مشخص نیست که آیا تغییر کاملا درست است یا غلط؛ به جای آن، به شما می‌گوید که چگونه گزینه‌های خود را رتبه بندی کنید. تغییراتی که ارزش زیادی به همراه خواهند داشت و نیازمند تلاش کمی هستند "بهتر" از آن‌هایی هستند که ارزش کمی دارند و نیازمند تلاش زیادی هستند.</p>

<p>حتی اگر سوال تان این است که آیا باید همین طور بمانیم و تغییر نکنیم؟ این معادله به شما پاسخ می‌دهد. از خودتان بپرسید: "ثابت ماندن چه ارزشی دارد؟" و "تلاش لازم برای ثابت ماندن چیست؟" و آن را با ارزش تغییر و تلاش برای تغییر مقایسه کنید.</p>

<p><strong>ارزش</strong></p>

<p>منظور ما از "ارزش" در این معادله چیست؟ ساده‌ترین تعریفی که از ارزش ارائه می‌شود این است:</p>

<p>جایی که این تغییر به هر کسی در هر جایی کمک می‌کند.</p>

<p>مهم‌ترین افرادی که به شما کمک می‌کنند کاربران شما هستند. با این حال، نوشتن با ویژگی هایی که شما را از نظر مالی حمایت کند نیز نوعی ارزش است - یا به نوعی برای شما ارزشمند است. در حقیقت، روش های مختلفی وجود دارد که یک تغییر می تواند ارزش داشته باشد. اینها فقط دو نمونه است.</p>

<p>بعضی اوقات، تعیین مقدار عددی دقیق هر تغییر خاص دشوار است. به عنوان مثال ، بگویید نرم افزار شما به کاهش وزن افراد کمک می کند. چگونه مقدار دقیق کمکتان به کاهش وزن در کسی را اندازه می گیرید؟ واقعاً نمی توانید. اما می توانید با دقت بدانید که برخی از ویژگی های این نرم افزار به افراد کمک می کند تا وزن زیادی کاهش دهند و برخی از ویژگی ها به هیچ وجه به کاهش وزن کمک نمی کنند. بنابراین، هنوز هم می توانید تغییرات را براساس ارزش آنها رتبه بندی کنید.</p>

<p>درک ارزش هر تغییر بیشتر اوقات از تجربه به عنوان یک توسعه دهنده و از انجام تحقیقات صحیح با کاربران برای پیدا کردن آنچه که بیشتر به آن‌ها کمک می‌کند، حاصل می‌شود.</p>

<p><strong>احتمال ارزش و ارزش بالقوه</strong></p>

<p>ارزش در واقع از دو عامل تشکیل شده است: احتمال ارزش (چقدر احتمال دارد که این تغییر به کاربر کمک کند) و مقدار بالقوه (این تغییر چقدر به کاربر در زمان هایی که به آن نیاز دارد کمک می کند)</p>

<p>برای مثال :</p>

<ul>
  <li>
    <p>یک ویژگی که می تواند جان کسی را نجات دهد، حتی اگر شانس مورد نیاز بودنش یک در میلیون باشد، هنوز یک ویژگی بسیار ارزشمند است و از ارزش بالقوه بالایی (نجات زندگی) برخوردار است، حتی اگر از احتمال کمی برخوردار باشد. مثال دیگر، در یک برنامه محاسباتی ممکن است ویژگی اضافه کنید که به افراد نابینا کمک می کند شماره ها را در سیستم وارد کنند. فقط درصد کمی از افراد نابینا هستند، اما بدون این ویژگی، آنها به هیچ وجه نمی توانند از نرم افزار شما استفاده کنند. باز هم، این ویژگی با وجود اینکه فقط روی گروه کوچکی از کاربران تأثیر می گذارد (احتمال ارزش کم) ، از ارزش بالقوه بالایی برخوردار است.</p>
  </li>
  <li>
    <p>اگر ویژگی وجود دارد که 100٪ کاربران شما را خوشحال میکند، این نیز یک ویژگی ارزشمند است. این یک ارزش بالقوه بسیار جزئی دارد (خوشحال کردن مردم)، اما تعداد بسیار زیادی از کاربران را تحت تاثیر قرار می دهد، بنابراین از احتمال ارزش بالایی برخوردار است.</p>
  </li>
  <li>
    <p>از طرف دیگر ، اگر ویژگی خاصی را اجرا کنید که شانس آن در خوشحال کردن مردم یک در میلیون باشد، این خیلی ارزش ندارد. این یک ویژگی با ارزش پتانسیل کم و احتمال ارزش کم است.</p>
  </li>
</ul>

<p>بنابراین ، هنگام مد نظر داشتن ارزش ، باید موارد زیر را نیز در نظر بگیرید:</p>

<ul>
  <li>
    <p>این تغییر برای چند کاربر(چند درصد)ارزشمند خواهد بود؟</p>
  </li>
  <li>
    <p>احتمال اینکه این ویژگی برای کاربر ارزشمند باشد چقدر است؟ یا به بیان دیگر: این ویژگی هر چند وقت یکبار ارزشمند خواهد بود؟</p>
  </li>
  <li>
    <p>چه زمانی ارزشمند است، چقدر ارزشمند خواهد بود؟</p>
  </li>
</ul>

<p><strong>تعادل آسیب</strong></p>

<p>برخی تغییرات علاوه بر کمکی که می کنند, ممکن است باعث آسیب شوند. به عنوان مثال ، ممکن است برخی از کاربران اگر نرم افزار شما به آنها تبلیغات نشان دهد، اذیت شوند، حتی اگر این تبلیغات به شما به عنوان یک توسعه دهنده کمک کند.</p>

<p>محاسبه ارزش یک تغییر شامل در نظر گرفتن میزان آسیبی است که ممکن است وارد کند و متعادل سازی آن نسبت به کمکی که به همراه دارد.</p>

<p><strong>ارزش داشتن کاربران</strong></p>

<p>ویژگی هایی که هیچ کاربری علاقه به استفاده ‍از آن ندارد هیچ ارزش آنی (لحظه ای) ندارند. اینها می تواند شامل ویژگی هایی باشد که کاربران نمی توانند پیدا کنند، ویژگی هایی که استفاده از آنها بسیار دشوار است یا ویژگی هایی که به راحتی به کسی کمک نمی کنند. آن‌ها ممکن است در آینده ارزشی داشته باشند، اما اکنون هیچ ارزشی ندارند.</p>

<p>این به این معنی است که در اغلب موارد، شما باید واقعا نرم‌افزار خود را راه اندازی کنید تا ارزشمند باشد. تغییری که انجام آن خیلی طولانی می شود در حقیقت می تواند دارای ارزشی معادل صفر باشد چون به موقع راه اندازی نمی‌شود تا به مردم به طور موثر کمک کند. در هنگام تعیین میزان مطلوبیت تغییرات، در نظر گرفتن زمانبندی انتشار می تواند مهم باشد.</p>

<p><strong>تلاش</strong></p>

<p>سنجیدن سعی و تلاش با استفاده از اعداد نسبت به ارزش دادن به آن راحت تر است. معمولاً می توانید تلاش را به عنوان "تعداد معینی از ساعت کار که توسط تعداد معینی از افراد انجام میشود" توصیف کنید. "به اندازه عمر صد نفر" نمونه ای از اندازه گیری عددی است که معمولاً برای تلاش شنیده می شود، نشان دادن ۱۰۰ سال کار توسط یک فرد، ۱ سال کار توسط ۱۰۰ نفر، ۲ سال کار توسط ۵۰ نفر و غیره.</p>

<p>با این حال، حتی با وجود اینکه تلاش می‌تواند به اعداد اندازه گیری شود، اما اندازه‌ گیری آن در موقعیت‌های عملی بسیار دشوار است - شاید هم غیر ممکن. تغییرات می‌توانند هزینه‌های پنهان بسیاری داشته باشند که می توان آن‌ها را به سختی پیش‌بینی کرد، مانند زمانی که برای تعمیر هرگونه اشکالات بوجود آمده ناشی از تغییرات در آینده خرج خواهید کرد. اما اگر شما یک توسعه دهنده نرم افزار باتجربه هستید ، احتمالاً می توانید تغییرات را با توجه به میزان تلاش برای انجام آنها رتبه بندی کنید، حتی اگر اعداد دقیق هر یک را نمی دانید.</p>

<p>هنگام در نظر گرفتن تلاشی که در ایجاد یک تغییر ایجاد می شود ، مهم است که تمام تلاشی را که ممکن است انجام شود، در نظر بگیرید، نه فقط زمانی که می خواهید برنامه نویسی کنید.</p>

<p>چه مدت تحقیق لازم است؟ توسعه دهندگان چقدر باید با یکدیگر در ارتباط باشند ؟ چقدر زمان صرف فکر کردن درباره تغییر می‌کنید؟ به طور خلاصه، هر مقدار زمانی که به یک تغییر مرتبط است، بخشی از هزینه تلاش است.</p>

<p><strong>نگهداری</strong></p>

<p>معادله ای که تاکنون داشته ایم بسیار ساده است ، اما یک عنصر مهم(زمان) را از دست می دهد. شما نه تنها باید یک تغییر را اجرا کنید، بلکه باید آن را با گذشت زمان حفظ کنید. همه تغییرات نیاز به نگهداری دارند. این خیلی واضح است اگر شما برنامه‌ای می نویسید که مالیات مردم را پرداخت میکند، باید هر سال آن را برای قوانین مالیاتی جدید به روز رسانی کنید. اما حتی تغییراتی که به نظر نمی رسد بلافاصله هزینه نگهداری طولانی مدت داشته باشند نیز هزینه ای خواهند داشت, حتی اگر این هزینه فقط نیاز به اطمینان از این است که کد هنگام تست در سال آینده همچنان کار می کند.</p>

<p>ما همچنین باید هم در حال حاضر و هم در آینده ارزش را در نظر بگیریم. وقتی ما تغییراتی را در سیستم خود اعمال کنیم ، این به کاربران فعلی ما کمک می کند ، اما ممکن است به همه کاربران آینده ما نیز کمک کند. حتی ممکن است روی تعداد کل کاربران در آینده تاثیر بگذارد ، بنابراین به طور کلی میزانی که نرم افزار به مردم کمک میکند را تغییر میدهد.</p>

<p>برخی ویژگی‌ها حتی در طول زمان نیز تغییر می‌کنند. برای مثال، داشتن یک نرم افزار مالیاتی که قوانین مالیاتی سال ۲۰۰۹ را درک کند در سال‌های ۲۰۰۹ تا ۲۰۱۰ با ارزش است، اما در سال ۲۰۱۱، دیگر چندان ارزشمند نیست. این ویژگی ای است که در طول زمان کم‌ارزش‌تر می‌شود. برخی از ویژگی‌ها نیز در طول زمان با ارزش تر می‌شوند.</p>

<p>بنابراین، با نگاه به این حقیقت، می‌بینیم که تلاش عملا شامل تلاش برای اجرا و تلاش برای نگهداری و ارزش عملا شامل ارزش هم اکنون و هم ارزش در آینده است. در شکل معادله، این به این شکل است:</p>

<p>
 $$ E = E_{i} + E_{m} $$
</p>

<p>
 $$ V = V_{n} + V_{f} $$
</p>

<p>$$ E_{i} $$</p>

<p>تلاش برای پیاده سازی است.</p>

<p>$$ E_{m} $$</p>

<p>تلاش برای نگهداری است.</p>

<p>$$ V_{n} $$</p>

<p>مقدار ارزش کنونی.</p>

<p>$$ V_{f} $$</p>

<p>مقدار ارزش آینده.</p>

<h3 id="معادله-کامل">معادله کامل</h3>

<p>وقتی همه اجزا در کنار هم قرار میگیرند ، معادله کامل به این شکل است:</p>
<p>$$ D = \frac{ V_{n} + V_{f} }{ E_{i} + E_{m} } $$</p>

<p>یا به فارسی :</p>

<blockquote>
  <p>مطلوبیت یک تغییر مستقیماً با ارزش حال به علاوه ارزش آینده متناسب است و به صورت معکوس متناسب با تلاش برای اجرا به علاوه تلاش برای نگهداری می باشد.</p>
</blockquote>

<p>این قانون اصلی طراحی نرم‌افزار است. با این حال، چیزهای بیشتری در مورد آن وجود دارد.</p>

<p><strong>کاهش معادله</strong></p>

<p>"ارزش آینده" و "تلاش برای نگهداری" هر دو به زمان بستگی دارند، وقتی ما معادله آن را در دنیای واقعی اعمال می‌کنیم باعث می شود چیزهای جالبی اتفاق بیفتد. برای نشان دادن اینها ، بیایید وانمود کنیم که می توانیم از پول برای حل معادله استفاده کنیم, هم برای ارزش و هم برای تلاش . "ارزش" با مقدار پولی که این تغییر برای ما به همراه خواهد داشت اندازه گیری خواهد شد. "تلاش" نیز بر اساس اینکه برای اجرای این تغییر چه مقدار پول باید هزینه شود، اندازه گیری می شود. شما نباید در دنیای واقعی به این شکل از این معادله استفاده کنید، اما به خاطر مثال ما، کارها را ساده می کند.</p>

<p>پس اجازه دهید بگوییم ما در جایی که معادله به این شکل است می خواهیم تغییری ایجاد کنیم :</p>
<p>$$ D = \frac{ $10.000 + $1000/day }{ $1.000 + $100/day } $$</p>

<p>به عبارت دیگر ، اجرای این تغییر 1000 دلار هزینه دارد (تلاش برای اجرا ، پایین سمت چپ) و بلافاصله 10،000 دلار برای ما به دست می آورد (ارزش فعلی ، بالا سمت چپ). سپس ، هر روز پس از آن ، به ما 1000 دلار (ارزش آینده ، بالا سمت راست) می رسد و نگهداری آن 100 دلار (تلاش برای نگهداری ، پایین سمت راست) هزینه می شود.</p>

<p>پس از 10 روز ، ارزش انباشته آینده بالغ بر 10 هزار دلار و تلاش برای نگهداری بالغ بر 1000 دلار است. این برابر با "ارزش فعلی" اصلی و هزینه اجرا بعد از ۱۰ روز است. پس از 100 روز، ارزش آینده بالغ بر 100000 دلار است و تلاش برای نگهداری به 10 هزار دلار می رسد.</p>

<p>پس از 1000 روز ، ارزش کل آینده به 1،000،000 دلار می رسد و تلاش برای نگهداری بالغ بر 100000 $. در این مرحله ، "ارزش فعلی" اصلی و هزینه اجرا در مقایسه بسیار کوچک به نظر می رسند. هرچه زمان می گذرد ، از اهمیت آنها کاسته میشود و در نهایت به طور کامل از اهمیت میشود. این ، بنابراین ، با گذشت زمان ، معادله ما به چنین چیزی کاهش می یابد:</p>
<p>$$ D = \frac{ V_{f} }{ E_{m} } $$</p>

<p>و در واقع، تقریباً تمام تصمیمات در طراحی نرم افزار كاملاً به اندازه گیری ارزش تغییر در آینده در مقابل تلاش برای نگهداری تقلیل می یابد. موقعیت‌هایی وجود دارند که در آن‌ها ارزش فعلی و تلاش اجرایی به اندازه کافی بزرگ هستند که در تصمیم‌گیری مهم باشند، اما بسیار نادر هستند. به طور کلی، سیستم‌های نرم‌افزاری آنقدر طولانی نگهداری می شوند که ارزش فعلی و تلاش برای اجرا در تمامی موارد در مقایسه با ارزش بلندمدت آینده و تلاش برای نگهداری، ناچیز است.</p>

<p><strong>آنچه شما انجام می دهید و نمی خواهید</strong></p>

<p>درس اول برای یادگیری در اینجا این است که ما می خواهیم از شرایطی جلوگیری کنیم که برای یک تغییر خاص، تلاش برای نگهداری، در آخر بیشتر از ارزش آینده باشد. به عنوان مثال ، تصور کنید که شما تغییری را اعمال می کنید که در طی پنج روز, تلاش و ارزش آن به این شکل باشد:</p>

<table>
  <thead>
    <tr>
      <th>ارزش</th>
      <th>تلاش</th>
      <th>روز</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$1.000</td>
      <td>$10</td>
      <td>1</td>
    </tr>
    <tr>
      <td>$100</td>
      <td>$100</td>
      <td>2</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$1.000</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$1</td>
      <td>$10.000</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$0.10</td>
      <td>$100.000</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$1111.10</td>
      <td>$111,110</td>
      <td>مجموع</td>
    </tr>
  </tbody>
</table>

<p>واضح است که این یک تغییر وحشتناک است که هرگز نباید ایجاد می کردید. اگر کارها با همین سرعت ادامه داشته باشند، شما به هیچ وجه قادر به حفظ سیستم نخواهید بود - این سیستم بی نهایت گران خواهد شد و ارزشی که هر روز کسب میکنید صفر دلار خواهد بود.</p>

<p>هر وضعیتی که در آن تلاش برای نگهداری سریع‌ تر از ارزش آن افزایش می‌یابد، شما را به دردسر می‌اندازد، حتی اگر ابتدا خوب به نظر برسد:</p>

<table>
  <thead>
    <tr>
      <th>ارزش</th>
      <th>تلاش</th>
      <th>روز</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$1000</td>
      <td>$1000</td>
      <td>1</td>
    </tr>
    <tr>
      <td>$2000</td>
      <td>$2000</td>
      <td>2</td>
    </tr>
    <tr>
      <td>$3000</td>
      <td>$4000</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$4000</td>
      <td>$8000</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$10,000</td>
      <td>$15,000</td>
      <td>مجموع</td>
    </tr>
  </tbody>
</table>

<p>راه حل ایده آل - و تنها راه برای تضمین موفقیت - طراحی سیستم های شما به گونه ای است که تلاش برای نگهداری با گذشت زمان کاهش یابد و در نهایت صفر شود (یا تا آنجا که ممکن است به آن نزدیک شوید). تا زمانی که می توانید این کار را انجام دهید ، مهم نیست که ارزش در آینده چقدر بزرگ یا کوچک می شود. لازم نیست نگران آن باشید. به عنوان مثال ، این جدول ها شرایط مطلوبی را نشان می دهند:</p>

<table>
  <thead>
    <tr>
      <th>ارزش</th>
      <th>تلاش</th>
      <th>روز</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0</td>
      <td>$1,000</td>
      <td>1</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$100</td>
      <td>2</td>
    </tr>
    <tr>
      <td>$100</td>
      <td>$10</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$1,000</td>
      <td>$0</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$10,000</td>
      <td>$0</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$11,110</td>
      <td>$1,110</td>
      <td>جمع</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>ارزش</th>
      <th>تلاش</th>
      <th>روز</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$10</td>
      <td>$20</td>
      <td>1</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$10</td>
      <td>2</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$5</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$1</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$10</td>
      <td>$0</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$50</td>
      <td>$36</td>
      <td>جمع</td>
    </tr>
  </tbody>
</table>

<p>تغییرات با ارزش آینده بالاتر همچنان مطلوب‌تر هستند. تا زمانی که هزینه نگهداری هر تصمیمی در طول زمان به صفر نزدیک می شود، شما در آینده به درد سر نخواهید افتاد.</p>

<p>از نظر تئوری ، تا زمانی که ارزش آینده همیشه از تلاش نگهداری بیشتر باشد ، تغییر همچنان مطلوب است. بنابراین ، در صورتی که تلاش برای نگهداری و ارزش آینده هر دو افزایش یابد ، می توانید تغییراتی ایجاد کنید، مادامی که ارزش آینده به اندازه کافی بزرگ باشد و از تلاش برای نگهداری بیشتر شود:</p>

<table>
  <thead>
    <tr>
      <th>ارزش</th>
      <th>تلاش</th>
      <th>روز</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0</td>
      <td>$1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>$2</td>
      <td>$2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>$4</td>
      <td>$3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$6</td>
      <td>$4</td>
      <td>4</td>
    </tr>
    <tr>
      <td>$8</td>
      <td>$5</td>
      <td>5</td>
    </tr>
    <tr>
      <td>$20</td>
      <td>$15</td>
      <td>جمع</td>
    </tr>
  </tbody>
</table>

<p>چنین تغییری بد نیست ، اما ایجاد تغییری که تلاش برای نگهداری آن کاهش یابد ، مطلوب تر است، حتی اگر تلاش بیشتری برای اجرای آن داشته باشد. اگر تلاش برای نگهداری کاهش یابد، تغییر با گذشت زمان بیشتر و مطلوب تر می شود. این باعث می شود که گزینه بهتری نسبت به سایر احتمالات باشد.</p>

<p>غالباً ، طراحی سیستمی که از تلاش تعمیر و نگهداری کمتری برخوردار باشد، به پیاده سازی و اجرای بسیار بیشتری نیاز دارد - کارهای طراحی و برنامه ریزی بیشتر لازم دارد. با این حال ، به یاد داشته باشید که تلاش برای اجرا تقریباً همیشه یک فاکتور ناچیز در تصمیم گیری در مورد طراحی است، و بیشتر باید نادیده گرفته شود.</p>

<p>به اختصار:</p>

<blockquote>
  <p><strong>بسیار مهم است که تلاش برای تعمیر و نگهداری را کاهش دهید تا اینکه تلاش برای اجرا را کاهش دهیم.</strong></p>
</blockquote>

<p>این یکی از مهمترین مواردی است که باید در مورد طراحی نرم افزار بدانید.</p>

<p>اما چه چیزی باعث تلاش برای نگهداری می شود؟ چگونه سیستم هایی را طراحی کنیم که تلاش نگهداری آنها به مرور کاهش یابد؟ این موضوع قسمت زیادی از بقیه این کتاب است. اما قبل از رسیدن به آن ، باید کمی بیشتر آینده را بررسی کنیم.</p>

<p><strong>کیفیت طراحی</strong></p>

<p>نوشتن نرم‌افزاری که به یک نفر کمک می‌کند بسیار آسان است. اما نوشتن نرم‌افزاری که به میلیون ها نفر در حال حاضر کمک می‌کند و به انجام این کار در آینده ادامه می‌دهد بسیار دشوارتر است.اما بیشتر تلاش برنامه نویسی کجا انجام می شود و چه زمانی بیشتر کاربران از این نرم افزار استفاده می کنند؟ همین الان، یا در دهه های آینده؟</p>

<p>پاسخ این است که برنامه نویسی های بیشتری در آینده روی پروژه انجام می شود - و در آینده میتواند به کاربران بسیار بیشتری نسبت به زمان حال کمک کند . نرم‌افزار شما باید در آینده رقابت کند و در آینده وجود داشته باشد، و تلاش برای نگهداری و تعداد کاربران آن افزایش خواهد داشت.</p>

<p>زمانی که ما این حقیقت را نادیده می‌گیریم که آینده وجود دارد و کارهایی انجام می‌دهیم که در حال حاضر در حال انجام است، نگهداری نرم‌افزار ما در آینده مشکل می‌شود. زمانی که نگهداری نرم‌افزار مشکل است، سخت است که به مردم کمک کنیم (یکی از اهداف ما در طراحی نرم‌افزار). اگر نمی‌توانید ویژگی‌های جدید را اضافه کنید و مشکلات را حل کنید، در نهایت با یک "نرم‌افزار بد" سر و کار دارید که نمیتواند به کاربران شما کمک کند و پر از باگ است.</p>

<p>این امر ما را به قانون زیر هدایت می‌کند:</p>

<blockquote>
  <p>سطح کیفیت طراحی شما باید متناسب با مدت زمان آینده باشد که در آن سیستم شما به مردم کمک خواهد کرد.</p>
</blockquote>

<p>اگر در حال نوشتن نرم‌افزاری هستید که تنها برای چند ساعت آینده مورد استفاده قرار خواهد گرفت، مجبور نیستید تلاش زیادی برای طراحی آن کنید. اما اگر نرم‌افزار شما برای ۱۰ سال آینده مورد استفاده قرار گیرد (و این خیلی بیشتر از آن چیزی است که انتظار دارید، حتی اگر فکر می‌کنید فقط برای ۶ ماه آینده مورد استفاده قرار خواهد گرفت)، پس باید کار زیادی را برای آن انجام دهید. زمانی که شک دارید، نرم‌افزار خود را طوری طراحی کنید که به مدت طولانی مورد استفاده قرار گیرد: خود را زندانی روش های دیگران نکنید، انعطاف‌پذیر باشید، هیچ تصمیمی نگیرید که دیگر نتوانید تغییر دهید، و به طراحی توجه زیادی کنید.</p>

<p><strong>پیامدهای غیرقابل پیش بینی</strong></p>

<p>بنابراین، هنگام طراحی نرم افزار، آینده باید تمرکز اصلی ما باشد. با این حال، یکی از مهمترین مواردی که باید در مورد هر نوع مهندسی بدانید این است:</p>

<blockquote>
  <p><strong>چیزهایی در مورد آینده وجود دارد که شما نمی‌دانید.</strong></p>
</blockquote>

<p>در حقیقت، وقتی نوبت به طراحی نرم‌افزار می‌رسد، شما نمی‌توانید بیشتر چیزها را در مورد آینده بدانید.</p>

<blockquote>
  <p><strong>رایج‌ترین و فاجعه بارترین خطای برنامه نویسان، پیش‌بینی چیزی در مورد آینده است که در واقع به طور قطعی نمی‌توانند بدانند.</strong></p>
</blockquote>

<p>به عنوان مثال ، تصور کنید که یک برنامه نویس در سال 1985 یک نرم افزار نوشته که دیسک های فلاپی خراب را درست می کند. نمی‌تواند چیز دیگری را تعمیر کند-تک تک قطعات آن کاملاً به نحوه کار فلاپی دیسک ها وابسته بود.</p>

<p>این نرم افزار اکنون منسوخ شده است، زیرا کسی دیگر از دیسک های فلاپی استفاده نمی کند. این برنامه نویس پیش بینی کرد "مردم همیشه از فلاپی دیسک استفاده خواهند کرد"-چیزی که او واقعاً نمی توانست بداند.</p>

<p>ممکن است بشود آینده کوتاه‌مدت را پیشبینی کرد، اما آینده بلند مدت تا حد زیادی ناشناخته است. اما بلند مدت برای ما مهم‌تر از کوتاه‌مدت است، زیرا تصمیمات طراحی ما عواقب بیشتری در دوره طولانی مدت خواهند داشت.</p>

<blockquote>
  <p>☆اگر سعی در پیش بینی آینده نداشته باشید، در ایمن ترین حالت قرار دارید , به جای آن تمام تصمیمات طراحی خود را براساس اطلاعات زمان حاضر مشخص کنید.</p>
</blockquote>

<p>اکنون ممکن است دقیقاً برعکس آنچه در این فصل تاکنون گفته ایم به نظر برسد، اما اینگونه نیست. آینده مهمترین نکته ای است که باید در تصمیم گیری های طراحی مورد توجه قرار گیرد. اما بین طراحی به روشی که امکان تغییرش در آینده را فراهم کند و تلاش برای پیش بینی آینده تفاوت وجود دارد.</p>

<p>به عنوان مثال، بگذارید بگوییم که شما یک گزینه ساده بین غذا خوردن و گرسنگی کشیدن دارید. برای انجام چنین انتخابی لازم نیست آینده را پیش بینی کنید - می دانید که غذا خوردن تصمیم بهتری است. چرا؟ زیرا همین الان شما را زنده نگه می دارد و زنده بودن آینده ای بهتر از مردن را رقم می زند. آینده مهم است و ما می خواهیم آن را در تصمیمات خود در نظر بگیریم. ما اکنون غذا خوردن را انتخاب می کنیم زیرا آینده بهتری ایجاد می کند. اما آینده لازم نیست پیش بینی شود - لازم نیست که جمله خاصی را بیان کنیم مانند "من الان غذا می خورم تا فردا زنده بمانم. "مهم نیست که فردا چه اتفاقی بیفتد، اگر شما الان غذا بخورید بهتر از این است که گرسنه بمیرید.</p>

<p>به همین ترتیب، در طراحی نرم‌افزار ما می‌توانیم تصمیم‌های خاصی را براساس اطلاعاتی که در حال حاضر داریم، به منظور ایجاد آینده‌ای بهتر (کاهش تلاش نگهداری و افزایش ارزش)، بدون نیاز به پیش‌بینی دقیق اتفاقاتی که در آن آینده رخ می‌دهد، بگیریم.</p>

<p>موارد استثنایی محدودی وجود دارد که بعضی اوقات می دانید دقیقاً چه اتفاقی قرار است در آینده کوتاه بیفتد و می توانید بر اساس آن تصمیم بگیرید. اما اگر می خواهید این کار را انجام دهید ، باید در مورد آینده بسیار مطمئن باشید و باید نزدیک باشد. مهم نیست که چقدر باهوش باشید، به هیچ وجه امکان پیش بینی دقیق آینده های بلند مدت وجود ندارد.</p>

<p>بیایید مثالی خارج از حوزه برنامه نویسی بزنیم: CD هایی که در سال 1979 برای جایگزینی نوارهای کاست به عنوان روش اصلی گوش دادن به موسیقی طراحی شده اند.چه کسی می توانست پیش بینی کند که 20 سال بعد ، DVD ها در همان اندازه و شکل ساخته شوند تا تولید کنندگان بتوانند درایوهای CD / DVD را برای رایانه ها بسازند؟</p>

<p>به همین دلیل است که ، در هر نوع مهندسی - از جمله زمینه توسعه نرم افزار - "اصول راهنما" داریم. اینها قوانین خاصی هستند که وقتی از آنها پیروی می کنیم ، بدون توجه به آنچه در آینده اتفاق می افتد ، کارها را به خوبی ادامه می دهند. این ها همان قوانین طراحی نرم افزار هستند- "اصول راهنمای" ما به عنوان طراحان.</p>

<p>پس بله، مهم است که به یاد داشته باشید که آینده وجود خواهد داشت. اما این به این معنا نیست که شما باید آن آینده را پیش‌بینی کنید. در عوض، توضیح می‌دهد که چرا شما باید با توجه به قوانین و مقررات این کتاب تصمیم بگیرید - چون آن‌ها در آینده به یک نرم‌افزار خوب منجر می‌شوند، مهم نیست که آینده چه چیزی را به ارمغان می‌آورد.</p>

<p>حتی پیش بینی همه روشهایی که ممکن است یک قاعده یا قانون خاص در آینده به شما کمک کند امکان پذیر نیست - اما این به شما کمک خواهد کرد ، و خوشحال خواهید شد که از این قانون در کار خود استفاده کرده اید. شما می توانید با قوانین و حقایقی که در اینجا می خوانید مخالفت کنید. لطفاً به نتیجه گیری خود درباره آنها بپردازید. اما باید به شما هشدار داده شود که اگر آنها را دنبال نکنید ، احتمالاً در جایی در پایین مسیر به مشکلی بر خواهید خورد، در آینده ای که نمی توانید پیش بینی کنید.</p>







	</div>
</div>




		<a href="#toc" class="go-top" style="font-family: Vazir">بازگشت به بالا</a>
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script type="text/javascript" src="/project/js/main.js"></script>
	</body>
</html>
