<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>نیرو های محرک طراحی نرم افزار | سادگی کد</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="نیرو های محرک طراحی نرم افزار" />
<meta name="author" content="محسن محمدی و الیاس سهرابی" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="زمانی که نرم‌افزاری می‌نویسیم، باید ایده‌ای از اینکه چرا این کار را انجام می‌دهیم و هدف نهایی چیست، داشته باشیم." />
<meta property="og:description" content="زمانی که نرم‌افزاری می‌نویسیم، باید ایده‌ای از اینکه چرا این کار را انجام می‌دهیم و هدف نهایی چیست، داشته باشیم." />
<link rel="canonical" href="http://localhost:4000/project/chapters/4-the-driving-forces-of-software-design.html" />
<meta property="og:url" content="http://localhost:4000/project/chapters/4-the-driving-forces-of-software-design.html" />
<meta property="og:site_name" content="سادگی کد" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-04T23:42:44+00:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"محسن محمدی و الیاس سهرابی"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/project/chapters/4-the-driving-forces-of-software-design.html"},"description":"زمانی که نرم‌افزاری می‌نویسیم، باید ایده‌ای از اینکه چرا این کار را انجام می‌دهیم و هدف نهایی چیست، داشته باشیم.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/project/siteicon.png"},"name":"محسن محمدی و الیاس سهرابی"},"@type":"BlogPosting","url":"http://localhost:4000/project/chapters/4-the-driving-forces-of-software-design.html","headline":"نیرو های محرک طراحی نرم افزار","dateModified":"2021-02-04T23:42:44+00:00","datePublished":"2021-02-04T23:42:44+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


		<link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic" rel="stylesheet">
		<link rel="stylesheet" media="print" href="/project/css/print.css">
		<link rel="stylesheet" media="screen" href="/project/css/screen.css">
		<link rel="icon" type="image/png" href="/project/images/favicon.png">

		
	</head>
	<body>
		<div class="cover" >
			<div class="wrap">
				<div class="book">
					<div class="front-cover" style="background-image: url(/project/images/cover.jpg)">
						<div class="cover-content" style="background-color: #00000096 !important; border-radius:5px; padding: 2px 20px 4px 20px;">
							<h1>سادگی کد</h1>
							<p class="author" style="color:#fff; filter: brightness(200%); font-size: 1.6em;">
								ترجمه:
								<br/>
								محسن محمدی و الیاس سهرابی
							</p>
						</div>
					</div>
					<ul class="ruled_paper">
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
					<div class="back-cover"></div>
				</div>
				<div class="pdf-cover">
					<h1>سادگی کد</h1>
					<p class="author">ترجمه: محسن محمدی و الیاس سهرابی</p>
				</div>
			</div>
			<img src="/project/images/cover.jpg" class="background">
		</div>

		<p class="wrap formats">
				<a class="active" href="/project/">تمام صفحه</a>
			&#183;
				<a  href="/project/full.html">نسخه html</a>
			&#183;
				<a href="/project/full.html#print-book">پرینت</a>
		</p>

		<div class="wrap">
	

	
<h3 id="toc">فهرست کتاب</h3>
<ul class="toc">
	
	
		<li>
	
		<a href="/project/chapters/1-preface.html#مقدمه">1. مقدمه</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/2-introduction.html#معرفی">2. معرفی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/3-the-missing-science.html#علم-گمشده">3. علم گمشده</a>
	

</li>
	
		<li>
	
		<a class="active" href="/project/chapters/4-the-driving-forces-of-software-design.html#نیرو-های-محرک-طراحی-نرم-افزار">4. نیرو های محرک طراحی نرم افزار</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/5-the-future.html#آینده">5. آینده</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/6-change.html#تغییر">6. تغییر</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/7-defects-and-design.html#نقص-ها-و-طراحی">7. نقص ها و طراحی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/8-Simplicity.html#سادگی">8. سادگی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/9-complexity.html#پیچیدگی">9. پیچیدگی</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/10-testing.html#آزمایش-کردن">10. آزمایش کردن</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/11-appendix-a.html#پیوست-اول">11. پیوست اول</a>
	

</li>
	
		<li>
	
		<a href="/project/chapters/12-appendix-b.html#پیوست-دوم">12. پیوست دوم</a>
	

</li>
	
</ul>


</div>

<div class="content">
	<div class="wrap">
		<h2 id="نیرو-های-محرک-طراحی-نرم-افزار"><span class="chapter-number">فصل 4</span> نیرو های محرک طراحی نرم افزار</h2>
<p class="editor-link"><a href="cloudcannon:collections/_chapters/4-the-driving-forces-of-software-design.md" class="btn"><strong>&#9998;</strong> Edit Chapter 4</a></p>
<p>زمانی که نرم‌افزاری می‌نویسیم، باید ایده‌ای از اینکه چرا این کار را انجام می‌دهیم و هدف نهایی چیست، داشته باشیم.</p>

<p>آیا راهی وجود دارد که بتوانیم هدف همه نرم‌افزارها را جمع‌ بندی کنیم؟ اگر چنین بیانیه‌ای امکان پذیر باشد، به کل علم طراحی نرم‌افزار جهت می‌دهد، زیرا ما می‌دانیم درحال انجام چه چیزی هستیم.</p>

<p>خوب، در حقیقت یک هدف واحد برای همه نرم‌افزارها وجود دارد:</p>

<p><strong>برای کمک به مردم</strong></p>

<p>ما می توانیم این مساله را به یک هدف خاص برای هر بخش از نرم افزار تقسیم کنیم. به عنوان مثال ، یک پردازشگر کلمه برای کمک به مردم در نوشتن چیزهایی وجود دارد و یک مرورگر وب برای کمک به افراد در مرور وب وجود دارد.</p>

<p>برخی از نرم افزارها فقط برای کمک به گروه های خاصی از افراد وجود دارند. به عنوان مثال ، بسیاری از نرم افزارهای حسابداری وجود دارد که برای کمک به حسابداران وجود دارد. اینها فقط آن گروه خاص از مردم را هدف قرار می دهند.</p>

<p>در مورد نرم افزاری که به حیوانات یا گیاهان کمک می کند چطور؟ خوب، هدف آن واقعاً کمک به مردم برای کمک به حیوانات یا گیاهان است.</p>

<p>نکته مهم در اینجا این است که نرم افزاری هرگز برای کمک به اشیا بی جان وجود ندارد. نرم افزار برای کمک به رایانه وجود ندارد، بلکه همیشه برای کمک به مردم وجود دارد. حتی وقتی کتابخانه می نویسید، برای کمک به برنامه نویسان که مردم هستند، می نویسید. شما هرگز برای کمک به رایانه چیزی نمی نویسید.</p>

<p>حال، "کمک" به چه معناست؟ از بعضی جهات، ذهنی است - آنچه به یک شخص کمک می کند ممکن است به دیگری کمک نکند. اما این کلمه تعریف فرهنگ لغت دارد ، بنابراین:</p>

<p>معنای کلمه به طور کامل در اختیار هر فرد نیست. فرهنگ لغت زبان جدید جهان آمریکایی Webster "کمک" را چنین تعریف می کند:</p>

<blockquote>
  <p>آسان تر کردن کار (یک شخص) مشخصاً … برای انجام بخشی از کار؛ سهولت کار یا تقسیم کار</p>
</blockquote>

<p>موارد زیادی وجود دارد که می توانید به مردم کمک کنید - تنظیم برنامه، نوشتن کتاب، برنامه ریزی رژیم غذایی و هر چیز دیگری. آنچه به شما کمک می کند بستگی به خود شما دارد اما هدف همیشه کمک است.</p>

<p>هدف نرم افزار "درآمدزایی" یا "نشان دادن میزان هوشمند بودن" نیست. هرکسی که تنها با این اهداف برنامه نویسی کند, هدف نرم افزار را نقض کرده و احتمالاً به دردسر می افتد. مسلماً ، این روشها میتواند به شما "کمک" کند ، اما این محدوده کمک بسیار محدود است و طراحی فقط با این اهداف ممکن است منجر به تولید نرم افزاری با کیفیت پایین تر نسبت به طراحی واقعی که برای کمک به افراد و انجام کاری که نیاز دارند و یا می‌خواهند انجام دهند، شود.</p>

<p>افرادی که نمی توانند کمک به شخص دیگری را تصور کنند، نرم افزار بدی می نویسند - یعنی نرم افزار آنها کمک چندانی به مردم نخواهد کرد. در حقیقت ، ممکن است این نظریه (به عنوان حدس ، براساس مشاهدات بسیاری از برنامه نویسان در طول زمان) وجود داشته باشد که توانایی بالقوه شما در نوشتن یک نرم افزار خوب فقط به توانایی تصور کمک به دیگری محدود می شود.</p>

<p>به طور کلی، زمانی که در حال تصمیم‌گیری درباره نرم‌افزار هستیم، اصل راهنمای ما می‌تواند این باشد که چگونه می‌توانیم کمک کنیم. (و به یاد داشته باشید، درجات مختلفی از کمک وجود دارد که فرد می‌تواند به تعداد زیادی یا چند نفر کمک کند) شما حتی می‌توانید ویژگی ها را اولویت‌بندی کنید. کدام ویژگی بیشترین کمک افراد کمک می‌کند؟ و آن ویژگی باید در اولویت قرار گیرد. مطالب بیشتری در مورد اولویت‌بندی ویژگی‌ها وجود دارد، اما "این کار چقدر به کاربران ما کمک می‌کند؟"  سوال اساسی خوبی است که درباره هر گونه تغییر پیشنهادی در سیستم نرم‌افزاری باید پرسید.</p>

<p>به طور کلی ، این هدف - کمک به مردم - مهمترین چیزی است که باید هنگام طراحی نرم افزار به خاطر بسپارید، و اکنون تعریف آن به ما این امکان را می دهد که یک علم واقعی در زمینه طراحی نرم افزار ایجاد و درک کنیم.</p>

<p><strong>برنامه دنیای واقعی</strong></p>

<p>چگونه می توانیم هدف نرم افزار را در پروژه های خود در دنیای واقعی اعمال کنیم؟ خوب ، بگذارید بگوییم ما در حال نوشتن یک ویرایشگر متن برای برنامه نویسان هستیم. اولین کاری که باید انجام دهیم تعیین هدف نرم افزار است. بهتر است ساده باشد، بنابراین بگذارید بگوییم هدف "کمک به برنامه نویسان برای ویرایش متن" است. خوب است که خصوصیات بیشتری داشته باشد، و گاهی اوقات مفید است، اما اگر گروه نتواند در مورد هدف خاصی به توافق برسد، حداقل یک هدف ساده مانند هدف بالا را ارائه دهید.</p>

<p>اکنون که هدف داریم، بیایید تمام ویژگی های درخواستی را بررسی کنیم. برای هر یک از این ویژگی ها ما می توانیم از خود بپرسیم، "این ویژگی چگونه به برنامه نویسان کمک می کند که متن را بهتر ویرایش کنند؟" اگر پاسخ این باشد: "نمی شود"، می توانیم بلافاصله آن ویژگی را از لیست خود خارج کنیم. سپس، برای هر یک از ویژگی های باقی مانده، می توانیم جواب را به عنوان یک جمله کوتاه یادداشت کنیم. به عنوان مثال، فرض کنید شخصی از ما میخواهد میانبرهای صفحه کلید را برای اقدامات معمول اضافه کنیم. می توانیم بگوییم، "این ویزگی به برنامه نویسان کمک می کند متن را ویرایش کنند زیرا به آنها امکان می دهد بدون وقفه طولانی در تایپ با برنامه تعامل سریعتری داشته باشند." (در صورتی که برای شرایط شما عملی به نظر نمی رسد، شما مجبور نیستید این موارد را یادداشت کنید فقط داشتن ایده برای پاسخ خودتان کافی است.)</p>

<p>همچنین چند دلیل مفید دیگر برای پرسیدن این سوال وجود دارد:</p>

<ul>
  <li>این کار به حل ابهامات در مورد توصیف این ویژگی یا نحوه پیاده‌سازی آن کمک می‌کند. به عنوان مثال، پاسخ بالا در مورد میانبرهای صفحه‌کلید به ما می‌گوید که پیاده‌سازی باید سریع باشد، چون کاربران ارزشی از آن خارج می‌شوند.</li>
  <li>این به تیم کمک می‌کند تا درباره ارزش یک ویژگی به توافق برسند. برخی افراد ممکن است ایده میان‌بر صفحه‌کلید را دوست نداشته باشند، اما همه باید بتوانند توافق کنند که پاسخ در بالا توضیح می‌دهد که چرا آن‌ها ارزشمند هستند. در حقیقت، برخی از توسعه دهندگان حتی ممکن است ایده بهتری از نحوه اجرای نیاز کاربر (تعامل با ویرایشگر متن)بدون میان‌بر صفحه‌کلید داشته باشند. خوبه! اگر پاسخ ما را به یک ایده بهتر از ویژگی باشد، باید آن را به جای آن اجرا کنیم. پاسخ به ما می‌گوید چیزی که واقعا مورد نیاز است، تنها چیزی که کاربر تصور می‌کند او می‌خواهد نیست.</li>
  <li>پاسخ به این پرسش آشکار می‌کند که برخی از ویژگی‌ها مهم‌تر از بقیه هستند. این کار به مدیران پروژه کمک می‌کند تا کار خود را اولویت‌بندی کنند.</li>
  <li>در بدترین حالت، اگر ویرایشگر متن ما با ویژگی‌های بسیار زیادی در طول زمان متورم شده باشد، پاسخ می‌تواند به ما کمک کند تصمیم بگیریم کدام ویژگی‌ها باید حذف شوند.</li>
</ul>

<p>ما همچنین می توانیم لیستی از اشکالات ایجاد کنیم، که می توانیم آنها را مرور کنیم و سوال مخالف را بپرسیم: "این اشکال چگونه مانع ویرایش متن برنامه نویسان می شود؟" بعضی اوقات پاسخ واضح است ، بنابراین در واقع نیازی به نوشتن نیست. به عنوان مثال ، اگر هنگام ذخیره فایل، برنامه خراب می شود، نیازی به توضیح دلیل بد بودن آن نیست.</p>

<p>به احتمال زیاد روشهای بی شماری دیگری برای کاربردی کردن هدف یک نرم افزار در کارهای روزمره وجود دارد. اینها فقط چند نمونه هستند.</p>

<p><strong>اهداف طراحی نرم‌افزار</strong></p>

<p>اکنون که هدف این نرم افزار را دانستیم، می توانیم کمی به علم طراحی نرم افزار خود جهت دهیم. از این هدف، ما می‌دانیم که وقتی نرم‌افزاری را می‌نویسیم، می‌خواهیم به مردم کمک کنیم. بنابراین، یکی از اهداف علم طراحی نرم‌افزار باید این باشد:</p>

<blockquote>
  <p><strong>اجازه دادن به ما برای نوشتن نرم‌افزاری که تا حد امکان مفید است.</strong></p>
</blockquote>

<p>دوم، ما معمولا از مردم می‌خواهیم که از کمک نرم افزار ما استفاده کنند. بنابراین هدف دوم ما این است:</p>

<blockquote>
  <p><strong>برای اینکه به نرم افزار ما کمک کند تا حد ممکن مفید باشد.</strong></p>
</blockquote>

<p>اکنون، این یک هدف عالی است، اما هر سیستم نرم افزاری در هر اندازه ای بسیار پیچیده است ، بنابراین کار بسیار سختی است که با گذشت زمان آن را مفید نگه داریم. در حقیقت، مشکل اصلی نوشتن و نگهداری نرم افزار مفید, امروزه طراحی و برنامه نویسی است. وقتی ایجاد یا اصلاح نرم افزار دشوار باشد، برنامه نویسان بیشتر وقت خود را صرف تمرکز بر "درست کار کردن" عملیات ها می کنند و زمان کمتری را نیز صرف کمک به کاربر می کنند.اما وقتی کار روی یک سیستم آسان است، برنامه نویسان می توانند زمان بیشتری را صرف تمرکز بر مفید بودن برای کاربر و زمان کمتری را روی جزئیات برنامه نویسی اختصاص دهند. به همین ترتیب، نگهداری از یک نرم افزار راحت تر و اطمینان از مفید بودن نرم افزار برای برنامه نویسان آسان تر است.</p>

<p>این ما را به هدف سوم می رساند:</p>

<blockquote>
  <p><strong>برای طراحی سیستم هایی که بتوانند به آسانی توسط برنامه نویسان ایجاد و نگهداری شوند، باید تا بتوانند - و تا آنجا که ممکن است - برای کاربران مفید باشند.</strong></p>
</blockquote>

<p>این هدف سوم همان هدفی است که به عنوان هدف طراحی نرم افزار تصور می شود، حتی اگر هرگز به صراحت بیان نشده باشد. با این حال، داشتن اهداف اول و دوم برای راهنمایی بسیار مهم است. ما می خواهیم به یاد داشته باشیم که مفید بودن در حال حاضر و در آینده انگیزه های هدف سوم است.</p>

<p>نکته ای که در مورد این هدف سوم باید به آن اشاره شود عبارت "به آسانترین شکل ممکن" است. ایده این است که ایجاد و نگهداری از برنامه های ما آسان باشد، نه اینکه آنها را دشوار یا پیچیده کند. این بدان معنا نیست که همه چیز بلافاصله آسان خواهد شد - گاهی اوقات برای یادگیری یک فناوری جدید و یا طراحی مطلوب زمان لازم است - اما در طولانی مدت، انتخاب های شما, ایجاد و نگهداری از نرم افزار شما را آسان تر می کند.</p>

<p>گاهی اوقات هدف اول (مفید بودن) و هدف سوم (سهولت در نگهداری) کمی در تضاد هستند - مفید بودن نرم افزار شما می تواند نگهداری و حفظ آن را دشوار کند. با این حال ، این دو هدف در طول تاریخ بیش از آنچه لازم بوده در تعارض بوده اند. ایجاد یک سیستم کاملاً قابل نگهداری که برای کاربران آن بسیار مفید باشد کاملاً امکان پذیر است. در حقیقت ، اگر آن را قابل نگهداری نکنید ، تحقق هدف دوم یعنی مفید بودن بسیار دشوار است. بنابراین ، هدف سوم مهم است زیرا در غیر این صورت دو هدف دیگر  محقق نمی شوند.</p>







	</div>
</div>




		<a href="#toc" class="go-top" style="font-family: Vazir">بازگشت به بالا</a>
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<script type="text/javascript" src="/project/js/main.js"></script>
	</body>
</html>
